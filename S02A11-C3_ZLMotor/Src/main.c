/******************************************************************************** *版    权： 2021-xxxx,  GaussianRobot *文 件 名： main.c主函数 *简    介： 用于初始化MCU外设 *作    者： LMmotor\忘川 *日    期： 2022.12.6 *功能描述： ******************************************************************************* *备注：         小部分其他功能：LABVIEW用于打印调试********************************************************************************/#include "main.h"#include "string.h"#include "stm32f4xx_hal.h"#include "canopen_od.h"#include "canopen_timer.h"#include "bsp_CAN.h"#include "usart/bsp_debug_usart.h"#include "ds402.h"#include "version.h"#include "bsp_app_function.h"                  const char Compiler_Date[] __attribute__((at(0x8020000 + 0x200))) = "S02A11" ;    /*将8020200写入S02A11 ，用于bootloader下位机读取bin文件该字段，确认bin文件正确*//*用于判断while循环是否运行*/uint32_t whileCNTtest=0;/*ADC句柄*/ADC_HandleTypeDef hadc1;ADC_HandleTypeDef hadc2;/*定时器句柄*/TIM_HandleTypeDef htim1;TIM_HandleTypeDef htim2;TIM_HandleTypeDef htim4;TIM_HandleTypeDef htim8;/*看门狗句柄*/IWDG_HandleTypeDef hiwdg;/*初始化函数*/void SystemClock_Config(void);static void MX_GPIO_Init(void);static void MX_ADC1_Init(void);static void MX_ADC2_Init(void);static void MX_TIM1_Init(void);static void MX_TIM2_Init(void);static void MX_TIM4_Init(void);static void MX_TIM8_Init(void);static void MX_NVIC_Init(void);static void MX_IWDG_Init(uint8_t prv,uint16_t rlv);/*------------------------------------------------* @function :系统初始化* @input    :请填写* @output   :请填写* @explain  :请填写* @author   :忘川* @date     :2022/12/16------------------------------------------------*/int main(void){	/*bootloader跳转过来地址，注意程序下载起始位置，改了以后需要编译一下生效*/    SCB->VTOR = 0X8020000;	/*bootloader中关闭了总中断口，此处打开*/	  __enable_irq();    HAL_Init();		/*配置滴答定时器500us一次，其中对于bootloader修增加了部分功能*/    SystemClock_Config();    MX_GPIO_Init();    MX_ADC1_Init();    MX_ADC2_Init();    MX_CAN2_Init();    MX_TIM1_Init();		/*用于电机2编码器定时器*/    MX_TIM2_Init();		/*用于电机1编码器定时器*/    MX_TIM4_Init();		/*用于提供CANopen协议栈定时基准100us*/    TIM6_Init();    MX_TIM8_Init();		/*电机控制参数初始化*/    MX_MotorControl_Init();		/*用于ADC采集到的相电流传输*/    MX_DMA_Init();			/*初始化看门狗1s时间计算(大概)Tout=((4*2^prv)*rlv)/32 (ms)*/		MX_IWDG_Init(IWDG_PRESCALER_64,500);	    MX_DEBUG_USART_Init();    MX_NVIC_Init();    printf("双轴驱动器网络测试，ping测试\r\n");	  	/*402相关参数初始化*/    Par_402_Init();        HAL_CAN_Receive_IT(&hcan2, CAN_FIFO0);		/*CANoepn协议栈变量、指针初始化*/    CANopen_Parameter_Init(&CANopen_Drive);		/*版本信息写入软件&硬件*/    Program_Version_Init(&ProgramVersion,PART_OF_ROBOT_TYPE,PART_OF_MAIN_VERSION,PART_OF_FUN_VERSION,PART_OF_SMALL_VERSION,PART_OF_HARDWARE_VERSION);    HardVersion_Init(&ProgramVersion,'S','A',11,PART_OF_HARDWARE_VERSION);		    /* 启动独立看门狗 */    __HAL_IWDG_START(&hiwdg);					/* 保证在调试代码时打断点，不会触发看门狗 */		__HAL_DBGMCU_FREEZE_IWDG();        __HAL_DBGMCU_FREEZE_WWDG();      while (1)    {			        whileCNTtest++;			#ifdef UART_DEBUG        if(Labview_uart_Flag1>=Labview_uart_Flag1CNT)        {//            Labview_uart();            Labview_uart_Flag1=0;        }/*ENDIF*/#endif    }/*ENDWHILE*/}/*ENDMIAN*//*------------------------------------------------* @function :配置并启动系统滴答定时器 500us* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/22------------------------------------------------*/void SystemClock_Config(void){    RCC_OscInitTypeDef RCC_OscInitStruct = {0};    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};    __HAL_RCC_PWR_CLK_ENABLE();    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;                         /*此处调试bootloader新增否则bootloader不能正常跳转*/    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)    {        Error_Handler();    }    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;                                        RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;    RCC_OscInitStruct.PLL.PLLM = 25;    RCC_OscInitStruct.PLL.PLLN = 336;    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;    RCC_OscInitStruct.PLL.PLLQ = 4;    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)    {        Error_Handler();    }    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)    {        Error_Handler();    }//    HAL_RCC_EnableCSS();       RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;      /*禁用内部高速时钟*/    RCC_OscInitStruct.HSIState = RCC_HSI_OFF;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)    {        Error_Handler();    }//  HAL_RCC_EnableCSS();    HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/2000);                  /*配置并启动系统滴答定时器 500us*/        HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);             /* 系统滴答定时器时钟源 */}/*------------------------------------------------* @function :其中：canopen协议栈需要注意定时器6的中断优先级不能太高* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_NVIC_Init(void){     HAL_NVIC_SetPriority(SysTick_IRQn, 2, 0);             /*中频任务*/    HAL_NVIC_EnableIRQ(SysTick_IRQn);	    HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 1, 0);       /*TIM1更新中断*/    HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);    HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 4, 0);       /*M1刹车*/    HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 1, 0);       /*TIM8更新中断*/    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);    HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, 4, 0);      /*M2刹车*/    HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);    HAL_NVIC_SetPriority(ADC_IRQn, 1, 1);                 /*高频任务*/    HAL_NVIC_EnableIRQ(ADC_IRQn);//    HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);//    HAL_NVIC_EnableIRQ(TIM2_IRQn);      HAL_NVIC_SetPriority(USART3_IRQn, 2, 1);              /*上位机串口接收中断*/    HAL_NVIC_EnableIRQ(USART3_IRQn);    HAL_NVIC_SetPriority(TIM6_DAC_IRQn,3, 0);             /*CANopen协议栈时基*/    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);		    HAL_NVIC_SetPriority(CAN2_RX0_IRQn,3, 0);             /*CAN接收中断*/    HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn);}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_ADC1_Init(void){    /* USER CODE BEGIN ADC1_Init 0 */    /* USER CODE END ADC1_Init 0 */    ADC_InjectionConfTypeDef sConfigInjected = {0};    ADC_ChannelConfTypeDef sConfig = {0};    /* USER CODE BEGIN ADC1_Init 1 */    /* USER CODE END ADC1_Init 1 */    /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)    */    hadc1.Instance = ADC1;    hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;    hadc1.Init.Resolution = ADC_RESOLUTION_12B;    hadc1.Init.ScanConvMode = ENABLE;    hadc1.Init.ContinuousConvMode = DISABLE;    hadc1.Init.DiscontinuousConvMode = DISABLE;    hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;    hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;    hadc1.Init.NbrOfConversion = 3;    hadc1.Init.DMAContinuousRequests = DISABLE;    hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;    if (HAL_ADC_Init(&hadc1) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_9;                   /*M1 U相电流采样*/    sConfigInjected.InjectedRank = 1;    sConfigInjected.InjectedNbrOfConversion = 4;    sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_15CYCLES;    sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISING;    sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T1_CC4;    sConfigInjected.AutoInjectedConv = DISABLE;    sConfigInjected.InjectedDiscontinuousConvMode = ENABLE;    sConfigInjected.InjectedOffset = 0;    if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_10;                  /*M2 U相电流采样*/    sConfigInjected.InjectedRank = 2;    if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_8;                  /*M1 V相电流采样*/    sConfigInjected.InjectedRank = 3;    if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_11;                 /*M2 V相电流采样*/    sConfigInjected.InjectedRank = 4;    if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.    */    sConfig.Channel = ADC_CHANNEL_3;                                  /*ADC1 CH3 母线电压 PA3 */    sConfig.Rank = 1;    sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;    sConfig.Offset = 0;    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)    {        Error_Handler();    }    /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.    */    sConfig.Channel = ADC_CHANNEL_13;                                /*ADC1 CH13 M2温度采集  PC3 */    sConfig.Rank = 2;    sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;    sConfig.Offset = 0;    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)    {        Error_Handler();    }    /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.    */    sConfig.Channel = ADC_CHANNEL_14;                               /*ADC1 CH14 M1温度采集  PC4 */    sConfig.Rank = 3;    sConfig.Offset = 0;    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)    {        Error_Handler();    }    /* USER CODE BEGIN ADC1_Init 2 */    /* USER CODE END ADC1_Init 2 */}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_ADC2_Init(void){    /* USER CODE BEGIN ADC2_Init 0 */    /* USER CODE END ADC2_Init 0 */    ADC_InjectionConfTypeDef sConfigInjected = {0};//        ADC_ChannelConfTypeDef sConfig = {0};    /* USER CODE BEGIN ADC2_Init 1 */    /* USER CODE END ADC2_Init 1 */    /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)    */    hadc2.Instance = ADC2;    hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;    hadc2.Init.Resolution = ADC_RESOLUTION_12B;    hadc2.Init.ScanConvMode = ENABLE;    hadc2.Init.ContinuousConvMode = DISABLE;    hadc2.Init.DiscontinuousConvMode = DISABLE;    hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;    hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;    hadc2.Init.DataAlign = ADC_DATAALIGN_LEFT;    hadc2.Init.NbrOfConversion = 1;    hadc2.Init.DMAContinuousRequests = DISABLE;    hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;    if (HAL_ADC_Init(&hadc2) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_8;              /*M1 电机V 相电流采样*/    sConfigInjected.InjectedRank = 1;    sConfigInjected.InjectedNbrOfConversion = 4;    sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_15CYCLES;    sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISING;    sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T8_CC4;    sConfigInjected.AutoInjectedConv = DISABLE;    sConfigInjected.InjectedDiscontinuousConvMode = ENABLE;    sConfigInjected.InjectedOffset = 0;    if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_11;             /*M2 电机V 相电流采样*/    sConfigInjected.InjectedRank = 2;    if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_15;             /*M1 电机W 相电流采样*/    sConfigInjected.InjectedRank = 3;    if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }    /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time    */    sConfigInjected.InjectedChannel = ADC_CHANNEL_12;             /*M2 电机W 相电流采样*/    sConfigInjected.InjectedRank = 4;    if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)    {        Error_Handler();    }}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_TIM1_Init(void){    /* USER CODE BEGIN TIM1_Init 0 */    /* USER CODE END TIM1_Init 0 */    TIM_SlaveConfigTypeDef sSlaveConfig = {0};    TIM_MasterConfigTypeDef sMasterConfig = {0};    TIM_OC_InitTypeDef sConfigOC = {0};    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};    /* USER CODE BEGIN TIM1_Init 1 */    /* USER CODE END TIM1_Init 1 */    htim1.Instance = TIM1;    htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);    htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;    htim1.Init.Period = ((PWM_PERIOD_CYCLES) / 2);    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;    htim1.Init.RepetitionCounter = (REP_COUNTER);    htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;    if (HAL_TIM_Base_Init(&htim1) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)    {        Error_Handler();    }    sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;    sSlaveConfig.InputTrigger = TIM_TS_ITR1;    if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)    {        Error_Handler();    }    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;    if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)    {        Error_Handler();    }    sConfigOC.OCMode = TIM_OCMODE_PWM1;    sConfigOC.Pulse = 0;    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;    if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)    {        Error_Handler();    }    sConfigOC.OCMode = TIM_OCMODE_PWM2;    sConfigOC.Pulse = (((PWM_PERIOD_CYCLES) / 2) - (HTMIN));    if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)    {        Error_Handler();    }    sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;    sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;    sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;    sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);    sBreakDeadTimeConfig.BreakState = TIM_BREAK_ENABLE;    sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;    sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_ENABLE;    if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)    {        Error_Handler();    }    /* USER CODE BEGIN TIM1_Init 2 */    /* USER CODE END TIM1_Init 2 */    HAL_TIM_MspPostInit(&htim1);}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_TIM2_Init(void){    /* USER CODE BEGIN TIM2_Init 0 */    /* USER CODE END TIM2_Init 0 */    TIM_Encoder_InitTypeDef sConfig = {0};    TIM_MasterConfigTypeDef sMasterConfig = {0};    /* USER CODE BEGIN TIM2_Init 1 */    /* USER CODE END TIM2_Init 1 */    htim2.Instance = TIM2;    htim2.Init.Prescaler = 0;    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;    htim2.Init.Period = M2_PULSE_NBR;    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;    sConfig.IC1Filter = M2_ENC_IC_FILTER;    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;    sConfig.IC2Filter = M2_ENC_IC_FILTER;    if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)    {        Error_Handler();    }    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)    {        Error_Handler();    }    /* USER CODE BEGIN TIM2_Init 2 */    /* USER CODE END TIM2_Init 2 */}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_TIM4_Init(void){    /* USER CODE BEGIN TIM3_Init 0 */    /* USER CODE END TIM3_Init 0 */    TIM_Encoder_InitTypeDef sConfig = {0};    TIM_MasterConfigTypeDef sMasterConfig = {0};    /* USER CODE BEGIN TIM3_Init 1 */    /* USER CODE END TIM3_Init 1 */    htim4.Instance = TIM4;    htim4.Init.Prescaler = 0;    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;    htim4.Init.Period = M1_PULSE_NBR;    htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;    htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;    sConfig.IC1Filter = M1_ENC_IC_FILTER;    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;    sConfig.IC2Filter = M1_ENC_IC_FILTER;    if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)    {        Error_Handler();    }    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;    if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)    {        Error_Handler();    }    /* USER CODE BEGIN TIM3_Init 2 */    /* USER CODE END TIM3_Init 2 */}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_TIM8_Init(void){    /* USER CODE BEGIN TIM8_Init 0 */    /* USER CODE END TIM8_Init 0 */    TIM_SlaveConfigTypeDef sSlaveConfig = {0};    TIM_MasterConfigTypeDef sMasterConfig = {0};    TIM_OC_InitTypeDef sConfigOC = {0};    TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};    /* USER CODE BEGIN TIM8_Init 1 */    /* USER CODE END TIM8_Init 1 */    htim8.Instance = TIM8;    htim8.Init.Prescaler = ((TIM_CLOCK_DIVIDER2) - 1);    htim8.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;    htim8.Init.Period = ((PWM_PERIOD_CYCLES2) / 2);    htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;    htim8.Init.RepetitionCounter = (REP_COUNTER2);    htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;    if (HAL_TIM_Base_Init(&htim8) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)    {        Error_Handler();    }    sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;    sSlaveConfig.InputTrigger = TIM_TS_ITR1;    if (HAL_TIM_SlaveConfigSynchro(&htim8, &sSlaveConfig) != HAL_OK)    {        Error_Handler();    }    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;    if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)    {        Error_Handler();    }    sConfigOC.OCMode = TIM_OCMODE_PWM1;    sConfigOC.Pulse = 0;    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;    if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)    {        Error_Handler();    }    if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)    {        Error_Handler();    }    sConfigOC.OCMode = TIM_OCMODE_PWM2;    sConfigOC.Pulse = (((PWM_PERIOD_CYCLES2) / 2) - (HTMIN2));    if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)    {        Error_Handler();    }    sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;    sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;    sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;    sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS2) / 2);    sBreakDeadTimeConfig.BreakState = TIM_BREAK_ENABLE;    sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;    sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_ENABLE;    if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)    {        Error_Handler();    }    /* USER CODE BEGIN TIM8_Init 2 */    /* USER CODE END TIM8_Init 2 */    HAL_TIM_MspPostInit(&htim8);}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/static void MX_GPIO_Init(void){    GPIO_InitTypeDef GPIO_InitStruct = {0};    /* GPIO Ports Clock Enable */    __HAL_RCC_GPIOE_CLK_ENABLE();    __HAL_RCC_GPIOB_CLK_ENABLE();    __HAL_RCC_GPIOD_CLK_ENABLE();    __HAL_RCC_GPIOA_CLK_ENABLE();    __HAL_RCC_GPIOI_CLK_ENABLE();    __HAL_RCC_GPIOH_CLK_ENABLE();    __HAL_RCC_GPIOC_CLK_ENABLE();    /*Configure GPIO pin : 急停引脚 */    GPIO_InitStruct.Pin = Start_Stop_Pin;    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);    /*CAN芯片使能引脚*/    GPIO_InitStruct.Pin = GPIO_PIN_13;    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);    /*Configure GPIO pin Output Level */    HAL_GPIO_WritePin(GPIOA, RS485_nRE_Pin, GPIO_PIN_RESET);    /*Configure GPIO pin Output Level */    HAL_GPIO_WritePin(RS485_DE_GPIO_Port, RS485_DE_Pin, GPIO_PIN_RESET);    /*Configure GPIO pins : M2_HALL_W_Pin M2_HALL_V_Pin M2_HALL_U_Pin M1_HALL_V_Pin                             M1_HALL_U_Pin */    GPIO_InitStruct.Pin = M2_HALL_W_Pin|M2_HALL_V_Pin|M2_HALL_U_Pin|M1_HALL_V_Pin                          |M1_HALL_U_Pin;    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);    /*Configure GPIO pin : M1_HALL_W_Pin */    GPIO_InitStruct.Pin = M1_HALL_W_Pin;    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;    GPIO_InitStruct.Pull = GPIO_NOPULL;    HAL_GPIO_Init(M1_HALL_W_GPIO_Port, &GPIO_InitStruct);    /*Configure GPIO pins : 3个指示灯引脚 */    GPIO_InitStruct.Pin = Fault_1_Pin|Fault_2_Pin|Normal_Pin;    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;    GPIO_InitStruct.Pull = GPIO_NOPULL;    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(Normal_GPIO_Port, &GPIO_InitStruct);    HAL_GPIO_WritePin(GPIOE, Fault_1_Pin|Fault_2_Pin|Normal_Pin, GPIO_PIN_SET);}/*------------------------------------------------* @function :* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/void MX_IWDG_Init(uint8_t prv,uint16_t rlv){    hiwdg.Instance = IWDG;    hiwdg.Init.Prescaler = prv;    hiwdg.Init.Reload = rlv;    HAL_IWDG_Init(&hiwdg);}void Error_Handler(void){    /* USER CODE BEGIN Error_Handler_Debug */    /* User can add his own implementation to report the HAL error return state */    /* USER CODE END Error_Handler_Debug */}/*------------------------------------------------* @function :断言* @input    :* @output   :* @explain  :* @author   :wangchuan* @date     :2022/12/30------------------------------------------------*/#ifdef  USE_FULL_ASSERT/**  * @brief  Reports the name of the source file and the source line number  *         where the assert_param error has occurred.  * @param  file: pointer to the source file name  * @param  line: assert_param error line source number  * @retval None  */void assert_failed(uint8_t *file, uint32_t line){    /* USER CODE BEGIN 6 */    /* User can add his own implementation to report the file name and line number,       tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */    /* USER CODE END 6 */}#endif /* USE_FULL_ASSERT */