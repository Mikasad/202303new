/* USER CODE BEGIN Header *//**  ******************************************************************************  * @file           : main.c  * @brief          : Main program body  ******************************************************************************  * @attention  *  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.  * All rights reserved.</center></h2>  *  * This software component is licensed by ST under Ultimate Liberty license  * SLA0044, the "License"; You may not use this file except in compliance with  * the License. You may obtain a copy of the License at:  *                             www.st.com/SLA0044  *  ******************************************************************************  *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include "main.h"#include "motorcontrol.h"#include "string.h"#include "stm32f4xx_hal.h"#include "canopen_od.h"#include "canopen_timer.h"#include "bsp_CAN.h"//#include "main.h"//#include "string.h"#include "usart/bsp_debug_usart.h"#include "key/bsp_key.h"#include "ds402.h"#include "Usart_Labview.h"#include "mc_config.h"#include "DriverCTRL_Com.h"#include "bsp_app_function.h"extern void Usart_Labview_Analyze(void);extern long Usart_ReadRegValue(u8 RxBuffer[],int i);extern u8 UsartReceiveDate;extern u8 UsartRxBuffer[50];extern STM_Handle_t STM[2];/* ???? ------------------------------------------------------------------*/extern __IO uint8_t DHCP_flag;extern MCI_Handle_t* pMCI[NBR_OF_MOTORS];//extern  u16 u16LwipR_BufId,  u16ComRead_BufId;;extern volatile u8 u8LwipR_Buf[1024];extern PID_Handle_t *pPIDSpeed[NBR_OF_MOTORS];/* ?????? --------------------------------------------------------------*/#define LED1_RCC_CLK_ENABLE()         __HAL_RCC_GPIOH_CLK_ENABLE()#define LED1_Pin                      GPIO_PIN_9#define LED1_GPIO_Port                GPIOH#define LED2_RCC_CLK_ENABLE()         __HAL_RCC_GPIOE_CLK_ENABLE()#define LED2_Pin                      GPIO_PIN_5#define LED2_GPIO_Port                GPIOE#define LED3_RCC_CLK_ENABLE()         __HAL_RCC_GPIOE_CLK_ENABLE()#define LED3_Pin                      GPIO_PIN_6#define LED3_GPIO_Port                GPIOEtypedef enum {    RECV_SUCCESS,    MOTION_SUCCESS,    RECV_PARA_ERR,    RECV_FAULT,} MOON_RECV_CODE;enum IPC_CONTENT_STEP {    RECV_STEP1=0,    RECV_STEP2,    RECV_STEP3,    RECV_STEP4,    RECV_STEP5,    RECV_STEP6,    RECV_STEP7,    RECV_STEP8,    RECV_STEP9,};enum{    QUERY_DATA = 0X01,    QUERY_VERSION = 0X02,    MOTION_CONTROL = 0X04,    EMERGENCY_STOP = 0X08,    QUERY_STATUS =0X10,};#define IPC_HEAD_MAGIC_NUM       (0x02)#define IPC_TAIL_MAGIC_NUM       (0x02)#define IPC_COMM_HEAD_MAGIC1     (0x52)#define IPC_COMM_HEAD_MAGIC2     (0x54)#define IPC_COMM_TAIL_MAGIC1     (0x0A)#define IPC_COMM_TAIL_MAGIC2     (0x0D)#define IPC_COMM_MAX_DATA        (0x20)#define IPC_COMM_RES_MAX_DATA    (0x5)#define RECV_COMPLETE           (0xAA)struct IPC_CONTENT_RESERVE {    uint8_t magic[IPC_HEAD_MAGIC_NUM];    uint8_t deviceIndex;    uint8_t dataSum;    uint8_t command;    uint8_t data[IPC_COMM_MAX_DATA];    uint8_t c_d_crc;    uint8_t tail[IPC_TAIL_MAGIC_NUM];};struct IPC_CONTENT_RESERVE g_ipc_uart_content;struct IPC_CONTENT_RESERVE ipc_uart_content_t;uint8_t aRxBuffer,Uart_N_100us_Flag,RxBufferCounter=0,UART3_RxBuffer;uint8_t RxBuffer[100]= {0,1,2,3,4,5};uint8_t TxBuffer[5][20]= {    {0x52, 0x54, 0x03,0x0D,0x01, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x0A,0x0D},    {0x52, 0x54, 0x03,0x07,0x02, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x01, 0x0A,0x0D},    {0x52, 0x54, 0x03,0x01,0x04, 0x01, 0x0A,0x0D},    {0x52, 0x54, 0x03,0x01,0x08, 0x01, 0x0A,0x0D},    {0x52, 0x54, 0x03,0x04,0x10, 0x00, 0x01, 0x02, 0x01, 0x0A,0x0D}};u8 g_uart_recv_ok=0;//extern uint32_t uwTick;int16_t LV_TxBuffer[10],TxBufferSize=10;uint8_t ipc_char_resolve(uint8_t *Inpara);uint8_t ipc_data_switch(void);u8 Usart3RxBuffer[50] = {0},Usart3_ReceiveDate=0,Usart3_ReceiveDate_OK;/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes *//* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD *//* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD *//* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM *//* USER CODE END PM *//* Private variables ---------------------------------------------------------*/ADC_HandleTypeDef hadc1;ADC_HandleTypeDef hadc2;TIM_HandleTypeDef htim1;TIM_HandleTypeDef htim2;TIM_HandleTypeDef htim3;TIM_HandleTypeDef htim4;TIM_HandleTypeDef htim8;UART_HandleTypeDef huart3;extern CAN_HandleTypeDef hcan2;extern CanTxMsgTypeDef TxMessage;extern CanRxMsgTypeDef RxMessage;/* USER CODE BEGIN PV *//* USER CODE END PV *//* Private function prototypes -----------------------------------------------*/void SystemClock_Config(void);static void MX_GPIO_Init(void);static void MX_ADC1_Init(void);static void MX_ADC2_Init(void);static void MX_TIM1_Init(void);static void MX_TIM2_Init(void);static void MX_TIM3_Init(void);static void MX_TIM4_Init(void);static void MX_TIM8_Init(void);static void MX_USART3_UART_Init(void);static void MX_NVIC_Init(void);void HALL2_Init_Electrical_Angle( void );void Labview_uart(void);void HALL1_Init_Electrical_Angle( void );/* USER CODE BEGIN PFP */extern void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az);extern void HALL_Init_Electrical_Angle( HALL_Handle_t * pHandle );extern uint8_t PrevHallState2,HallState2;extern int32_t VelocityPLLSwitch ;//原16位extern PID_Handle_t *pPIDIq[NBR_OF_MOTORS];extern int16_t HAL_Init_Electrical_Angle2,HAL_CommutationAngle2;extern void Kalman_Filter(float Gyro,float Accel) ;extern void Kalman_Filter_Init(void);extern void Atlas_LoadDefaultPar(void);void LoadFlashParams(void);extern PosCtrl_Handle_t *pPosCtrl[NBR_OF_MOTORS];extern double MedianFiltering(double ResrcData);extern double Low_Pass(double data);//extern ANGLE_DATA_F Acc_ANGLE;//extern SENSOR_DATA_I16 MPU6050_ACC_LAST;     // 传感器ACC值//extern SENSOR_DATA_I16 MPU6050_GYRO_LAST;		// 传感器GYRO值uint8_t MC_StartStopFlag = 6,MC_StartStopFlag1=0,PositionModeFlag1=0,PositionModeFlag2=0,Labview_uart_Flag=0,Labview_uart_Flag1=0,Labview_uart_Flag1CNT=2;int32_t PrintTest = 0,Countrer_1ms_CNT=200,Countrer2_1ms_CNT=200;uint32_t whileCNTtest=0;float	CurrentPosition1,TargetPosition1,MoveDuration1,CurrentPosition2,TargetPosition2,MoveDuration2;int32_t CurrentPosition11,CurrentPosition22;float SetPositionMotor1=3.14159,PreSetPositionMotor1,SetPositionMotor2=0,SetPositionMotor2_Temp=2,MPU6050_ACC_LAST_X,MPU6050_ACC_LAST_X1;uint8_t Motor_Judgment = 0,Motor_Judgment_Temp=0;extern long SetPulseMotor1,SetPulseMotor2,ActuralSpeedMotor1,ActuralSpeedMotor2;u8 RefreshCmd_Type = 0;s16 Angle_Switch2=3,Angle_Switch = 3;extern u8 HallStudyFlag1,HallStudyFlag2;extern IMU_DATA imuData;extern s16 sensors[10];extern void IMU_BDF_07_DATA(char *chr);s32 imuData_Pitch,imuData_Yaw,imuData_Roll;float imuDataScale = 45.4;//45.511111extern LOOP_TEST_T	loopTestPar;								//环路测试相关参数extern float  gfInjectPhase[2];extern long glTemp_Inject;/* USER CODE END PFP */* Private user code ---------------------------------------------------------*//* USER CODE BEGIN 0 *//* USER CODE END 0 *//**  * @brief  The application entry point.  * @retval int  */int main(void){    /* USER CODE BEGIN 1 */    /* USER CODE END 1 */    /* MCU Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_ADC1_Init();    MX_ADC2_Init();    MX_CAN2_Init();    MX_TIM1_Init();    MX_TIM2_Init();//Motor2//  MX_TIM3_Init();//Motor1    MX_TIM4_Init();    TIM6_Init();    MX_TIM8_Init();//  MX_USART3_UART_Init();    MX_MotorControl_Init();    MX_DEBUG_USART_Init();    /* Initialize interrupts */    MX_NVIC_Init();    /* USER CODE BEGIN 2 */    /* 调用格式化输出函数打印输出数据 */    printf("双轴驱动器网络测试，ping测试\n");    Par_402_Init();    HAL_UART_Receive_IT(&husart_debug,&aRxBuffer,1);    /* USER CODE END 2 */    HAL_CAN_Receive_IT(&hcan2, CAN_FIFO0);    CANopen_Parameter_Init(&CANopen_Drive);    /* Infinite loop */    /* USER CODE BEGIN WHILE */    loopTestPar.InjectPoint[M1] = INJECT_POINT_CURRREF;    loopTestPar.InjectType[M1] = INJECT_TYPE_SIN_DIRECT;  //sin曲线    loopTestPar.InjectFreq[M1] = 3;    loopTestPar.InjectCurrAmp[M1] = 1000;    while (1)    {        /* USER CODE END WHILE *///    LWIP_Data_Process();        whileCNTtest++;#ifdef UART_DEBUG        if(Labview_uart_Flag1>=Labview_uart_Flag1CNT)        {            Labview_uart();            Labview_uart_Flag1=0;        }#endif#ifdef Usart_Labview        Usart_Labview_Analyze();   //指令解析#endif        if(Angle_Switch == 3&&Angle_Switch2 == 3) //换向完成        {//            Independent_Motor_Control();            Motor_Control();        }    }}u8 P_V_I_Switch = 0;extern u16 CNT_1MS[MAX_AXES];void Motor_Control(){//    if(Driver_Data[M1].device_control_data.Modes_of_operation == 3) //速度模式//    {//        if(MC_StartStopFlag !=6)//        {//            MC_StartStopFlag = 8;//            P_V_I_Switch = 2;//        }//    }//    else if (Driver_Data[M1].device_control_data.Modes_of_operation == 4) //转矩模式//    {//        MC_StartStopFlag = 5;//        Motor_Judgment = 1;//    }//    else if (Driver_Data[M1].device_control_data.Modes_of_operation == 1 ) //位置模式//    {//        if(MC_StartStopFlag != 7)//        {//            MC_StartStopFlag = 8;//            P_V_I_Switch = 3;//            Motor_Judgment = 1;//        }//    }    switch ( MC_StartStopFlag )    {    case 0:        break;    case 1:        if(STM[0].bState > 6 || STM[1].bState > 6)        {            MC_AcknowledgeFaultMotor1();            MC_AcknowledgeFaultMotor2();        }        MC_StartMotor1();        MC_StartMotor2();        MC_StartStopFlag = 6;        break;    case 2:  //电机启动        if(Motor_Judgment == 1)        {            MC_StartMotor1();            MC_StopMotor2();        }        else if(Motor_Judgment == 2)        {            MC_StartMotor2();            MC_StopMotor1();        }        else if(Motor_Judgment == 3)        {            MC_StartMotor1();            MC_StartMotor2();        }        MC_StartStopFlag = 6;        break;    case 3://电机刹车！待完善        if(Motor_Judgment == 1)            pCtrlPar[M1].SetVelMotor = 0;        else if(Motor_Judgment == 2)            pCtrlPar[M2].SetVelMotor = 0;        else if(Motor_Judgment == 3)        {            pCtrlPar[M1].SetVelMotor = 0;            pCtrlPar[M2].SetVelMotor = 0;        }        MC_StartStopFlag = 6;        break;    case 4://电机停止        if(Motor_Judgment == 1)            MC_StopMotor1();        else if(Motor_Judgment == 2)            MC_StopMotor2();        else if(Motor_Judgment == 3)        {            MC_StopMotor1();            MC_StopMotor2();        }        MC_StartStopFlag = 0;        VelocityPLLSwitch = 0 ;        break;    case 5:  //力矩环        if(Motor_Judgment == 1)            MC_ProgramTorqueRampMotor1(pCtrlPar[M1].SetTorqueMotor, 0);        else if(Motor_Judgment == 2)            MC_ProgramTorqueRampMotor2(pCtrlPar[M2].SetTorqueMotor, 0);        else if(Motor_Judgment == 3)        {            MC_ProgramTorqueRampMotor1(pCtrlPar[M1].SetTorqueMotor, 0);            MC_ProgramTorqueRampMotor2(pCtrlPar[M2].SetTorqueMotor, 0);        }        break;    case 6:	//	底P小 速度h切Q位置h        if(HallStudyFlag1 == 0 &&  STM[0].bState > 5)        {            Countrer_1ms_CNT = pCtrlPar[M1].hDurationms+500;            Countrer2_1ms_CNT = pCtrlPar[M2].hDurationms+500;            VelocityPLLSwitch = 1 ;   //锁相环            if(LockAxleON_OFF == 0)            {                MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, pCtrlPar[M1].hDurationms );                CurrentPosition1 =  MC_GetCurrentPosition1();                pMCI[M1]->pPosCtrl->PositionControlRegulation = 0;                CNT_1MS[M1] = 0;                PositionModeFlag1 = 0;            }            else if(LockAxleON_OFF ==1)            {                if(pCtrlPar[M1].SetVelMotor != 0)                {                    MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, pCtrlPar[M1].hDurationms );                    CurrentPosition1 =  MC_GetCurrentPosition1();                    pMCI[M1]->pPosCtrl->PositionControlRegulation = 0;                    CNT_1MS[M1] = 0;                    PositionModeFlag1 = 0;                }                else                {                    if(PositionModeFlag1 == 0)                    {                        if(CNT_1MS[M1] >= Countrer_1ms_CNT)                        {                            if(pCtrlPar[M1].Vel_PLL_Motor == 0)                            {                                if((CNT_1MS[M1] < Countrer_1ms_CNT+50)&&(CNT_1MS[M1] > Countrer_1ms_CNT+10))                                {                                    CurrentPosition1 =  MC_GetCurrentPosition1();                                    pMCI[M1]->pPosCtrl->PositionControlRegulation = 1;                                    MC_ProgramPositionCommandMotor1( CurrentPosition1, 0 );                                }                                else if(CNT_1MS[M1] >= Countrer_1ms_CNT+50)                                {                                    PositionModeFlag1 = 1;                                    pMCI[M1]->pPosCtrl->PositionControlRegulation = 1;                                    CNT_1MS[M1] = Countrer_1ms_CNT+50 ;                                }                                else                                {                                    MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, pCtrlPar[M1].hDurationms );                                }                            }                            else                            {                                CNT_1MS[M1] = Countrer_1ms_CNT ;                                MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, pCtrlPar[M1].hDurationms );                            }                        }                        else                        {                            MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, pCtrlPar[M1].hDurationms );                            CurrentPosition1 =  MC_GetCurrentPosition1();                            pMCI[M1]->pPosCtrl->PositionControlRegulation = 0;                        }                    }                    else if(PositionModeFlag1 == 1)                    {                        CNT_1MS[M1] = Countrer_1ms_CNT+500 ;                        SetPulseMotor1 =  CurrentPosition1;                        MC_ProgramPositionCommandMotor1( SetPulseMotor1, 0 );                        TargetPosition1 =  MC_GetTargetPosition1();                    }                }            }            if(HallStudyFlag2 == 0 &&  STM[1].bState > 5)            {                if(LockAxleON_OFF == 0)                {                    MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, pCtrlPar[M2].hDurationms );                    CurrentPosition2 =  MC_GetCurrentPosition2();                    pMCI[M2]->pPosCtrl->PositionControlRegulation = 0;                    CNT_1MS[M2] = 0;                    PositionModeFlag2 = 0;                }                else if(LockAxleON_OFF == 1)                {                    if(pCtrlPar[M2].SetVelMotor != 0)                    {                        MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, pCtrlPar[M2].hDurationms );                        CurrentPosition2 =  MC_GetCurrentPosition2();                        pMCI[M2]->pPosCtrl->PositionControlRegulation = 0;                        CNT_1MS[M2] = 0;                        PositionModeFlag2 = 0;                    }                    else                    {                        if(PositionModeFlag2 == 0)                        {                            if(CNT_1MS[M2] >= Countrer2_1ms_CNT)                            {                                if(pCtrlPar[M2].Vel_PLL_Motor == 0)                                {                                    if((CNT_1MS[M2] < Countrer2_1ms_CNT+50)&&(CNT_1MS[M2] > Countrer2_1ms_CNT+10))                                    {                                        CurrentPosition2 =  MC_GetCurrentPosition2();                                        pMCI[M2]->pPosCtrl->PositionControlRegulation = 1;                                        MC_ProgramPositionCommandMotor2( CurrentPosition2, 0 );                                    }                                    else if(CNT_1MS[M2] >= Countrer2_1ms_CNT+50)                                    {                                        PositionModeFlag2 = 1;                                        pMCI[M2]->pPosCtrl->PositionControlRegulation = 1;                                        CNT_1MS[M2] = Countrer2_1ms_CNT+50 ;                                    }                                    else                                    {                                        MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, pCtrlPar[M2].hDurationms );                                    }                                }                                else                                {                                    CNT_1MS[M2] = Countrer2_1ms_CNT ;                                    MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, pCtrlPar[M2].hDurationms );                                }                            }                            else                            {                                MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, pCtrlPar[M2].hDurationms );                                CurrentPosition2 =  MC_GetCurrentPosition2();                                pMCI[M2]->pPosCtrl->PositionControlRegulation = 0;                            }                        }                        else if(PositionModeFlag2 == 1)                        {                            CNT_1MS[M2] = Countrer2_1ms_CNT+500 ;                            SetPulseMotor2 =  CurrentPosition2;                            MC_ProgramPositionCommandMotor2( SetPulseMotor2, 0 );                            TargetPosition2 =  MC_GetTargetPosition2();                        }                    }                }            }            break;        case 7:  //位置环            if(P_V_I_Switch == 3)            {                if(Motor_Judgment == 1)                {                    pMCI[M1]->pPosCtrl->PositionControlRegulation = 1;                    MC_ProgramPositionCommandMotor1( SetPulseMotor1, 0 );                }                else if(Motor_Judgment == 2)//电机2位置环                {                    pMCI[M2]->pPosCtrl->PositionControlRegulation = 1;                    MC_ProgramPositionCommandMotor2( SetPulseMotor2, 0 );                }                else if(Motor_Judgment == 3)//电机2位置环                {                    pMCI[M1]->pPosCtrl->PositionControlRegulation = 1;                    MC_ProgramPositionCommandMotor1( SetPulseMotor1, 0 );                    pMCI[M2]->pPosCtrl->PositionControlRegulation = 1;                    MC_ProgramPositionCommandMotor2( SetPulseMotor2, 0 );                }            }            break;        case 8:            pCtrlPar[M1].SetVelMotor = 0 ;            pCtrlPar[M2].SetVelMotor = 0 ;            pMCI[M1]->pPosCtrl->PositionControlRegulation = 0;            pMCI[M2]->pPosCtrl->PositionControlRegulation = 0;            MC_ProgramSpeedRampMotor2( pCtrlPar[M2].SetVelMotor, 100 );            MC_ProgramSpeedRampMotor1( pCtrlPar[M1].SetVelMotor, 100 );            if(P_V_I_Switch == 2)            {                HAL_Delay(200);                if(pCtrlPar[M1].Vel_PLL_Motor==0 && pCtrlPar[M2].Vel_PLL_Motor ==0)                {                    MC_StartStopFlag = 6;                    CNT_1MS[M1] = 0;                    CNT_1MS[M2] = 0;                    PositionModeFlag1 = 0;                }            }            else  if(P_V_I_Switch == 3)            {                HAL_Delay(200);                if(pCtrlPar[M1].Vel_PLL_Motor==0 && pCtrlPar[M2].Vel_PLL_Motor ==0)                {                    HAL_Delay(300);                    MC_StartStopFlag = 7;                    SetPulseMotor1 = MC_GetCurrentPosition1();                    SetPulseMotor2 = MC_GetCurrentPosition2();                    pPosCtrl[M1]->Theta = SetPulseMotor1 ;                    pPosCtrl[M2]->Theta = SetPulseMotor2 ;                }            }            break;        case 9:            Atlas_Write_Flash(Atlas_Flash_Addr,FlashArray);            MC_StartStopFlag = 0;            break;        case 10:            Atlas_Read_Flash(Atlas_Flash_Addr,FlashArray);            MC_StartStopFlag = 0;            MC_AlignEncoderMotor1();            break;        case 11:            MC_AlignEncoderMotor1();            MC_StartStopFlag = 0;            break;        case 12:            MC_AlignEncoderMotor2();            MC_StartStopFlag = 0;            break;        default:            break;        }        /* USER CODE BEGIN 3 */        /* USER CODE END 3 */    }	}    /**      * @brief System Clock Configuration      * @retval None      */    void SystemClock_Config(void)    {        RCC_OscInitTypeDef RCC_OscInitStruct = {0};        RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};        /** Configure the main internal regulator output voltage        */        __HAL_RCC_PWR_CLK_ENABLE();        __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);        /** Initializes the CPU, AHB and APB busses clocks        */        RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;        RCC_OscInitStruct.HSEState = RCC_HSE_ON;        RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;        RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;        RCC_OscInitStruct.PLL.PLLM = 25;        RCC_OscInitStruct.PLL.PLLN = 336;        RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;        RCC_OscInitStruct.PLL.PLLQ = 4;        if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)        {            Error_Handler();        }        /** Initializes the CPU, AHB and APB busses clocks        */        RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK                                      |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;        RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;        RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;        RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;        RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;        if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)        {            Error_Handler();        }        /** Enables the Clock Security System        */        HAL_RCC_EnableCSS();    }    /**      * @brief NVIC Configuration.      * @retval None      */    static void MX_NVIC_Init(void)    {        /* TIM1_UP_TIM10_IRQn interrupt configuration */        HAL_NVIC_SetPriority(SysTick_IRQn, 2, 0);        HAL_NVIC_EnableIRQ(SysTick_IRQn);        HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 1, 0);        HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);        /* TIM1_BRK_TIM9_IRQn interrupt configuration *///  HAL_NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 4, 1);//  HAL_NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);        /* TIM8_UP_TIM13_IRQn interrupt configuration */        HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 1, 0);        HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);        /* TIM8_BRK_TIM12_IRQn interrupt configuration *///  HAL_NVIC_SetPriority(TIM8_BRK_TIM12_IRQn, 4, 1);//  HAL_NVIC_EnableIRQ(TIM8_BRK_TIM12_IRQn);        /* ADC_IRQn interrupt configuration */        HAL_NVIC_SetPriority(ADC_IRQn, 1, 1);        HAL_NVIC_EnableIRQ(ADC_IRQn);        /* TIM3_IRQn interrupt configuration *///  HAL_NVIC_SetPriority(TIM3_IRQn, 3, 0);//  HAL_NVIC_EnableIRQ(TIM3_IRQn);        /* TIM4_IRQn interrupt configuration *///  HAL_NVIC_SetPriority(TIM4_IRQn, 0, 0);//  HAL_NVIC_EnableIRQ(TIM4_IRQn);//	HAL_NVIC_DisableIRQ(TIM4_IRQn);        /* TIM2_IRQn interrupt configuration */        HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);        HAL_NVIC_EnableIRQ(TIM2_IRQn);        /* USART1_IRQn interrupt configuration *///  HAL_NVIC_SetPriority(USART1_IRQn, 3, 1);//  HAL_NVIC_EnableIRQ(USART1_IRQn);        HAL_NVIC_SetPriority(USART3_IRQn, 2, 1);        HAL_NVIC_EnableIRQ(USART3_IRQn);        /* EXTI0_IRQn interrupt configuration */        HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);        HAL_NVIC_EnableIRQ(EXTI0_IRQn);        HAL_NVIC_SetPriority(EXTI9_5_IRQn, 2, 0);        HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);        HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);        HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);        HAL_NVIC_SetPriority(TIM6_DAC_IRQn,3, 0);        HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);        HAL_NVIC_SetPriority(CAN2_RX0_IRQn,3, 0);        HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn);//	HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);    }    /**      * @brief ADC1 Initialization Function      * @param None      * @retval None      */    static void MX_ADC1_Init(void)    {        /* USER CODE BEGIN ADC1_Init 0 */        /* USER CODE END ADC1_Init 0 */        ADC_InjectionConfTypeDef sConfigInjected = {0};        ADC_ChannelConfTypeDef sConfig = {0};        /* USER CODE BEGIN ADC1_Init 1 */        /* USER CODE END ADC1_Init 1 */        /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)        */        hadc1.Instance = ADC1;        hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;        hadc1.Init.Resolution = ADC_RESOLUTION_12B;        hadc1.Init.ScanConvMode = ENABLE;        hadc1.Init.ContinuousConvMode = DISABLE;        hadc1.Init.DiscontinuousConvMode = DISABLE;        hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;        hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;        hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;        hadc1.Init.NbrOfConversion = 3;        hadc1.Init.DMAContinuousRequests = DISABLE;        hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;        if (HAL_ADC_Init(&hadc1) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_15;        sConfigInjected.InjectedRank = 1;        sConfigInjected.InjectedNbrOfConversion = 4;        sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_15CYCLES;        sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISING;        sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T1_CC4;        sConfigInjected.AutoInjectedConv = DISABLE;        sConfigInjected.InjectedDiscontinuousConvMode = ENABLE;        sConfigInjected.InjectedOffset = 0;        if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_10;        sConfigInjected.InjectedRank = 2;        if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_8;        sConfigInjected.InjectedRank = 3;        if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_11;        sConfigInjected.InjectedRank = 4;        if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.        */        sConfig.Channel = ADC_CHANNEL_3;        sConfig.Rank = 1;        sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;        sConfig.Offset = 0;        if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)        {            Error_Handler();        }        /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.        */        sConfig.Channel = ADC_CHANNEL_8;        sConfig.Rank = 2;        sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;        sConfig.Offset = 0;        if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)        {            Error_Handler();        }        /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.        */        sConfig.Channel = ADC_CHANNEL_6;        sConfig.Rank = 3;        sConfig.Offset = 0;        if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN ADC1_Init 2 */        /* USER CODE END ADC1_Init 2 */    }    /**      * @brief ADC2 Initialization Function      * @param None      * @retval None      */    static void MX_ADC2_Init(void)    {        /* USER CODE BEGIN ADC2_Init 0 */        /* USER CODE END ADC2_Init 0 */        ADC_InjectionConfTypeDef sConfigInjected = {0};//        ADC_ChannelConfTypeDef sConfig = {0};        /* USER CODE BEGIN ADC2_Init 1 */        /* USER CODE END ADC2_Init 1 */        /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)        */        hadc2.Instance = ADC2;        hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;        hadc2.Init.Resolution = ADC_RESOLUTION_12B;        hadc2.Init.ScanConvMode = ENABLE;        hadc2.Init.ContinuousConvMode = DISABLE;        hadc2.Init.DiscontinuousConvMode = DISABLE;        hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;        hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;        hadc2.Init.DataAlign = ADC_DATAALIGN_LEFT;        hadc2.Init.NbrOfConversion = 1;        hadc2.Init.DMAContinuousRequests = DISABLE;        hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;        if (HAL_ADC_Init(&hadc2) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_8;        sConfigInjected.InjectedRank = 1;        sConfigInjected.InjectedNbrOfConversion = 4;        sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_15CYCLES;        sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISING;        sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T8_CC4;        sConfigInjected.AutoInjectedConv = DISABLE;        sConfigInjected.InjectedDiscontinuousConvMode = ENABLE;        sConfigInjected.InjectedOffset = 0;        if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_11;        sConfigInjected.InjectedRank = 2;        if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_9;        sConfigInjected.InjectedRank = 3;        if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time        */        sConfigInjected.InjectedChannel = ADC_CHANNEL_12;        sConfigInjected.InjectedRank = 4;        if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK)        {            Error_Handler();        }        /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.        *///  sConfig.Channel = ADC_CHANNEL_3;//  sConfig.Rank = 1;//  sConfig.SamplingTime = ADC_SAMPLETIME_15CYCLES;//  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)//  {//    Error_Handler();//  }        /* USER CODE BEGIN ADC2_Init 2 */        /* USER CODE END ADC2_Init 2 */    }    /**      * @brief TIM1 Initialization Function      * @param None      * @retval None      */    static void MX_TIM1_Init(void)    {        /* USER CODE BEGIN TIM1_Init 0 */        /* USER CODE END TIM1_Init 0 */        TIM_SlaveConfigTypeDef sSlaveConfig = {0};        TIM_MasterConfigTypeDef sMasterConfig = {0};        TIM_OC_InitTypeDef sConfigOC = {0};        TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};        /* USER CODE BEGIN TIM1_Init 1 */        /* USER CODE END TIM1_Init 1 */        htim1.Instance = TIM1;        htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);        htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;        htim1.Init.Period = ((PWM_PERIOD_CYCLES) / 2);        htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;        htim1.Init.RepetitionCounter = (REP_COUNTER);        htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;        if (HAL_TIM_Base_Init(&htim1) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)        {            Error_Handler();        }        sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;        sSlaveConfig.InputTrigger = TIM_TS_ITR1;        if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)        {            Error_Handler();        }        sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;        sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;        if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)        {            Error_Handler();        }        sConfigOC.OCMode = TIM_OCMODE_PWM1;        sConfigOC.Pulse = 0;        sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;        sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;        sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;        sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;        sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;        if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)        {            Error_Handler();        }        sConfigOC.OCMode = TIM_OCMODE_PWM2;        sConfigOC.Pulse = (((PWM_PERIOD_CYCLES) / 2) - (HTMIN));        if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)        {            Error_Handler();        }        sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;        sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;        sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_1;        sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);        sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;        sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_LOW;        sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;        if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN TIM1_Init 2 */        /* USER CODE END TIM1_Init 2 */        HAL_TIM_MspPostInit(&htim1);    }    /**      * @brief TIM2 Initialization Function      * @param None      * @retval None      */    static void MX_TIM2_Init(void)    {        /* USER CODE BEGIN TIM2_Init 0 */        /* USER CODE END TIM2_Init 0 */        TIM_Encoder_InitTypeDef sConfig = {0};        TIM_MasterConfigTypeDef sMasterConfig = {0};        /* USER CODE BEGIN TIM2_Init 1 */        /* USER CODE END TIM2_Init 1 */        htim2.Instance = TIM2;        htim2.Init.Prescaler = 0;        htim2.Init.CounterMode = TIM_COUNTERMODE_UP;        htim2.Init.Period = M2_PULSE_NBR;        htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;        htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;        sConfig.EncoderMode = TIM_ENCODERMODE_TI12;        sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;        sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;        sConfig.IC1Prescaler = TIM_ICPSC_DIV1;        sConfig.IC1Filter = M2_ENC_IC_FILTER;        sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;        sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;        sConfig.IC2Prescaler = TIM_ICPSC_DIV1;        sConfig.IC2Filter = M2_ENC_IC_FILTER;        if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)        {            Error_Handler();        }        sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;        sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;        if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN TIM2_Init 2 */        /* USER CODE END TIM2_Init 2 */    }    /**      * @brief TIM3 Initialization Function      * @param None      * @retval None      */    static void MX_TIM4_Init(void)    {        /* USER CODE BEGIN TIM3_Init 0 */        /* USER CODE END TIM3_Init 0 */        TIM_Encoder_InitTypeDef sConfig = {0};        TIM_MasterConfigTypeDef sMasterConfig = {0};        /* USER CODE BEGIN TIM3_Init 1 */        /* USER CODE END TIM3_Init 1 */        htim4.Instance = TIM4;        htim4.Init.Prescaler = 0;        htim4.Init.CounterMode = TIM_COUNTERMODE_UP;        htim4.Init.Period = M1_PULSE_NBR;        htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;        htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;        sConfig.EncoderMode = TIM_ENCODERMODE_TI12;        sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;        sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;        sConfig.IC1Prescaler = TIM_ICPSC_DIV1;        sConfig.IC1Filter = M1_ENC_IC_FILTER;        sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;        sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;        sConfig.IC2Prescaler = TIM_ICPSC_DIV1;        sConfig.IC2Filter = M1_ENC_IC_FILTER;        if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK)        {            Error_Handler();        }        sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;        sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;        if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN TIM3_Init 2 */        /* USER CODE END TIM3_Init 2 */    }    /**      * @brief TIM4 Initialization Function      * @param None      * @retval None      *///static void MX_TIM4_Init(void)//{////  /* USER CODE BEGIN TIM4_Init 0 */////  /* USER CODE END TIM4_Init 0 */////  TIM_ClockConfigTypeDef sClockSourceConfig = {0};////  TIM_HallSensor_InitTypeDef sConfig = {0};////  TIM_MasterConfigTypeDef sMasterConfig = {0};////  /* USER CODE BEGIN TIM4_Init 1 */////  /* USER CODE END TIM4_Init 1 */////  htim4.Instance = TIM4;////  htim4.Init.Prescaler = 84-1;////  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;////  htim4.Init.Period = M1_HALL_TIM_PERIOD;////  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;////  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;////  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)////  {////    Error_Handler();////  }////  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;////  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)////  {////    Error_Handler();////  }////  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;////  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;////  sConfig.IC1Filter = M1_HALL_IC_FILTER;////  sConfig.Commutation_Delay = 0;////  if (HAL_TIMEx_HallSensor_Init(&htim4, &sConfig) != HAL_OK)////  {////    Error_Handler();////  }////  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC2REF;////  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;////  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)////  {////    Error_Handler();////  }//  /* USER CODE BEGIN TIM4_Init 2 *///	GPIO_InitTypeDef GPIO_Initure;//  TIM_IC_InitTypeDef Ic_ch1Config;//	TIM_IC_InitTypeDef Ic_ch2Config;//	TIM_IC_InitTypeDef Ic_ch3Config;////	/* gpio init */////	HALL_TIM_RCC_CLK_ENABLE();		                        //??????////	HALL_TIM_GPIO_CLK_ENABLE();////	 __HAL_RCC_TIM4_CLK_ENABLE();//	__HAL_RCC_GPIOD_CLK_ENABLE();//	//?????????IO???//	GPIO_Initure.Pin = M1_HALL_H2_Pin|M1_HALL_H1_Pin;//M1_HALL_H3_Pin//	GPIO_Initure.Mode = GPIO_MODE_AF_PP;//	GPIO_Initure.Pull = GPIO_PULLDOWN;//	GPIO_Initure.Speed = GPIO_SPEED_HIGH;//	GPIO_Initure.Alternate = GPIO_AF2_TIM4;//	HAL_GPIO_Init(GPIOD, &GPIO_Initure);//	/* TIM4 init *///    htim4.Instance = TIM4;							//?????4//    htim4.Init.Prescaler = 3-1;			//?????//    htim4.Init.CounterMode = TIM_COUNTERMODE_UP;		//??????//    htim4.Init.Period = 65535;				//??????//    htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; //??????,TIM_CLOCKDIVISION_DIV1[???]////	HAL_TIM_IC_Init(&htim4);                           //???????????//	/* TIM4 Capture init *///    Ic_ch1Config.ICPolarity = TIM_ICPOLARITY_BOTHEDGE;      //?????//	Ic_ch1Config.ICSelection = TIM_ICSELECTION_DIRECTTI;	//???TI1?//	Ic_ch1Config.ICPrescaler = TIM_ICPSC_DIV1;          	//??????,???//	Ic_ch1Config.ICFilter= 0;                         	    //???????;??//	HAL_TIM_IC_ConfigChannel(&htim4,&Ic_ch1Config,TIM_CHANNEL_1);//??TIM4??1//	HAL_TIM_IC_Start_IT(&htim4,TIM_CHANNEL_1);   	    //??TIM4?????1,????????////	Ic_ch2Config.ICPolarity = TIM_ICPOLARITY_BOTHEDGE;      //?????//	Ic_ch2Config.ICSelection = TIM_ICSELECTION_DIRECTTI;	//???TI1?//	Ic_ch2Config.ICPrescaler = TIM_ICPSC_DIV1;          	//??????,???//	Ic_ch2Config.ICFilter= 0;                         	    //???????;??//	HAL_TIM_IC_ConfigChannel(&htim4,&Ic_ch2Config,TIM_CHANNEL_2);//??TIM4??2//	HAL_TIM_IC_Start_IT(&htim4,TIM_CHANNEL_2);   	    //??TIM4?????2,????????//////	Ic_ch3Config.ICPolarity = TIM_ICPOLARITY_BOTHEDGE;      //?????////	Ic_ch3Config.ICSelection = TIM_ICSELECTION_DIRECTTI;	//???TI1?////	Ic_ch3Config.ICPrescaler = TIM_ICPSC_DIV1;          	//??????,???////	Ic_ch3Config.ICFilter = 0;                         	    //???????;??////	HAL_TIM_IC_ConfigChannel(&htim4,&Ic_ch3Config,TIM_CHANNEL_3);//??TIM4??3////	HAL_TIM_IC_Start_IT(&htim4,TIM_CHANNEL_3);   	    //??TIM4?????3,????????//////  HALL_Init_Electrical_Angle( &HALL_M1 );//  /* USER CODE END TIM4_Init 2 *///}//static void MX_TIM4_Init(void)//{//  /* USER CODE BEGIN TIM4_Init 0 *///  /* USER CODE END TIM4_Init 0 *///  TIM_ClockConfigTypeDef sClockSourceConfig = {0};//  TIM_HallSensor_InitTypeDef sConfig = {0};//  TIM_MasterConfigTypeDef sMasterConfig = {0};//  /* USER CODE BEGIN TIM4_Init 1 *///  /* USER CODE END TIM4_Init 1 *///  htim4.Instance = TIM4;//  htim4.Init.Prescaler = 84-1;//  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;//  htim4.Init.Period = M1_HALL_TIM_PERIOD;//  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;//  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;//  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)//  {//    Error_Handler();//  }//  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;//  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)//  {//    Error_Handler();//  }//  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;//  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;//  sConfig.IC1Filter = M1_HALL_IC_FILTER;//  sConfig.Commutation_Delay = 0;//  if (HAL_TIMEx_HallSensor_Init(&htim4, &sConfig) != HAL_OK)//  {//    Error_Handler();//  }//  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC2REF;//  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;//  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)//  {//    Error_Handler();//  }//  /* USER CODE BEGIN TIM4_Init 2 */////  HALL_Init_Electrical_Angle( &HALL_M1 );//  /* USER CODE END TIM4_Init 2 *///}    /**      * @brief TIM8 Initialization Function      * @param None      * @retval None      */    static void MX_TIM8_Init(void)    {        /* USER CODE BEGIN TIM8_Init 0 */        /* USER CODE END TIM8_Init 0 */        TIM_SlaveConfigTypeDef sSlaveConfig = {0};        TIM_MasterConfigTypeDef sMasterConfig = {0};        TIM_OC_InitTypeDef sConfigOC = {0};        TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};        /* USER CODE BEGIN TIM8_Init 1 */        /* USER CODE END TIM8_Init 1 */        htim8.Instance = TIM8;        htim8.Init.Prescaler = ((TIM_CLOCK_DIVIDER2) - 1);        htim8.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;        htim8.Init.Period = ((PWM_PERIOD_CYCLES2) / 2);        htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;        htim8.Init.RepetitionCounter = (REP_COUNTER2);        htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;        if (HAL_TIM_Base_Init(&htim8) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)        {            Error_Handler();        }        sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;        sSlaveConfig.InputTrigger = TIM_TS_ITR1;        if (HAL_TIM_SlaveConfigSynchro(&htim8, &sSlaveConfig) != HAL_OK)        {            Error_Handler();        }        sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;        sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;        if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)        {            Error_Handler();        }        sConfigOC.OCMode = TIM_OCMODE_PWM1;        sConfigOC.Pulse = 0;        sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;        sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;        sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;        sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;        sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;        if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)        {            Error_Handler();        }        if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)        {            Error_Handler();        }        sConfigOC.OCMode = TIM_OCMODE_PWM2;        sConfigOC.Pulse = (((PWM_PERIOD_CYCLES2) / 2) - (HTMIN2));        if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)        {            Error_Handler();        }        sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;        sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;        sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_1;        sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS2) / 2);        sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;        sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_LOW;        sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;        if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN TIM8_Init 2 */        /* USER CODE END TIM8_Init 2 */        HAL_TIM_MspPostInit(&htim8);    }    /**      * @brief USART1 Initialization Function      * @param None      * @retval None      *///static void MX_USART1_UART_Init(void)//{//  /* USER CODE BEGIN USART1_Init 0 *///  /* USER CODE END USART1_Init 0 *///  /* USER CODE BEGIN USART1_Init 1 *///  /* USER CODE END USART1_Init 1 *///  huart1.Instance = USART1;//  huart1.Init.BaudRate = 115200;//  huart1.Init.WordLength = UART_WORDLENGTH_8B;//  huart1.Init.StopBits = UART_STOPBITS_1;//  huart1.Init.Parity = UART_PARITY_NONE;//  huart1.Init.Mode = UART_MODE_TX_RX;//  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;//  huart1.Init.OverSampling = UART_OVERSAMPLING_16;//  if (HAL_UART_Init(&huart1) != HAL_OK)//  {//    Error_Handler();//  }//  /* USER CODE BEGIN USART1_Init 2 *///  /* USER CODE END USART1_Init 2 *///}    static void MX_USART3_UART_Init(void)    {        /* USER CODE BEGIN USART1_Init 0 */        /* USER CODE END USART1_Init 0 */        /* USER CODE BEGIN USART1_Init 1 */        /* USER CODE END USART1_Init 1 */        huart3.Instance = USART3;        huart3.Init.BaudRate = 115200;        huart3.Init.WordLength = UART_WORDLENGTH_8B;        huart3.Init.StopBits = UART_STOPBITS_1;        huart3.Init.Parity = UART_PARITY_NONE;        huart3.Init.Mode = UART_MODE_TX_RX;        huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;        huart3.Init.OverSampling = UART_OVERSAMPLING_16;        if (HAL_UART_Init(&huart3) != HAL_OK)        {            Error_Handler();        }        /* USER CODE BEGIN USART1_Init 2 */        /* USER CODE END USART1_Init 2 */    }    /**      * @brief GPIO Initialization Function      * @param None      * @retval None      */    static void MX_GPIO_Init(void)    {        GPIO_InitTypeDef GPIO_InitStruct = {0};//  /* GPIO Ports Clock Enable *///  __HAL_RCC_GPIOE_CLK_ENABLE();//  __HAL_RCC_GPIOB_CLK_ENABLE();//  __HAL_RCC_GPIOA_CLK_ENABLE();//  __HAL_RCC_GPIOI_CLK_ENABLE();//  __HAL_RCC_GPIOH_CLK_ENABLE();//  __HAL_RCC_GPIOC_CLK_ENABLE();//  __HAL_RCC_GPIOD_CLK_ENABLE();//  /*Configure GPIO pin Output Level *///  HAL_GPIO_WritePin(M1_DISSIPATIVE_BRK_GPIO_Port, M1_DISSIPATIVE_BRK_Pin, GPIO_PIN_RESET);//  /*Configure GPIO pin : M1_DISSIPATIVE_BRK_Pin *///  GPIO_InitStruct.Pin = M1_DISSIPATIVE_BRK_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//  GPIO_InitStruct.Pull = GPIO_PULLDOWN;//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;//  HAL_GPIO_Init(M1_DISSIPATIVE_BRK_GPIO_Port, &GPIO_InitStruct);        /* GPIO Ports Clock Enable */        __HAL_RCC_GPIOE_CLK_ENABLE();        __HAL_RCC_GPIOB_CLK_ENABLE();        __HAL_RCC_GPIOD_CLK_ENABLE();        __HAL_RCC_GPIOA_CLK_ENABLE();        __HAL_RCC_GPIOI_CLK_ENABLE();        __HAL_RCC_GPIOH_CLK_ENABLE();        __HAL_RCC_GPIOC_CLK_ENABLE();        /*Configure GPIO pin : Start_Stop_Pin */        GPIO_InitStruct.Pin = Start_Stop_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;        GPIO_InitStruct.Pull = GPIO_NOPULL;        HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);        /*Configure GPIO pin Output Level */        HAL_GPIO_WritePin(GPIOE, M1_DISSIPATIVE_BRK_Pin|Fault_1_Pin|Fault_2_Pin|Normal_Pin, GPIO_PIN_SET);        /*Configure GPIO pin Output Level */        HAL_GPIO_WritePin(GPIOA, RS485_nRE_Pin, GPIO_PIN_RESET);        /*Configure GPIO pin Output Level */        HAL_GPIO_WritePin(RS485_DE_GPIO_Port, RS485_DE_Pin, GPIO_PIN_RESET);        /*Configure GPIO pins : Version_2_Pin Version_1_Pin Version_3_Pin *///  GPIO_InitStruct.Pin = Version_2_Pin|Version_1_Pin|Version_3_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);        /*Configure GPIO pin : Encoder_2_A_Pin */        GPIO_InitStruct.Pin = Encoder_2_A_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;        GPIO_InitStruct.Pull = GPIO_NOPULL;        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;        GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;        HAL_GPIO_Init(Encoder_2_A_GPIO_Port, &GPIO_InitStruct);        /*Configure GPIO pins : M2_HALL_W_Pin M2_HALL_V_Pin M2_HALL_U_Pin M1_HALL_V_Pin                                 M1_HALL_U_Pin */        GPIO_InitStruct.Pin = M2_HALL_W_Pin|M2_HALL_V_Pin|M2_HALL_U_Pin|M1_HALL_V_Pin                              |M1_HALL_U_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;        GPIO_InitStruct.Pull = GPIO_NOPULL;        HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);        /*Configure GPIO pin : M1_HALL_W_Pin */        GPIO_InitStruct.Pin = M1_HALL_W_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;        GPIO_InitStruct.Pull = GPIO_NOPULL;        HAL_GPIO_Init(M1_HALL_W_GPIO_Port, &GPIO_InitStruct);        /*Configure GPIO pins : PC12 PC11 PC10 *///  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11|GPIO_PIN_10;//  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;//  GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;//  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);        /*Configure GPIO pin : M1_DISSIPATIVE_BRK_Pin */        GPIO_InitStruct.Pin = M1_DISSIPATIVE_BRK_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;        GPIO_InitStruct.Pull = GPIO_PULLUP;        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;        HAL_GPIO_Init(M1_DISSIPATIVE_BRK_GPIO_Port, &GPIO_InitStruct);        /*Configure GPIO pin : Start_Stop_Pin *///  GPIO_InitStruct.Pin = Start_Stop_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);//  /*Configure GPIO pins : SPI_CS2_Pin SPI_CS1_Pin RS485_nRE_Pin *///  GPIO_InitStruct.Pin = SPI_CS2_Pin|SPI_CS1_Pin|RS485_nRE_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;//  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);//  /*Configure GPIO pins : RS485_RX_Pin RS485_TX_Pin *///  GPIO_InitStruct.Pin = RS485_RX_Pin|RS485_TX_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;//  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;//  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);//  /*Configure GPIO pin : RS485_DE_Pin *///  GPIO_InitStruct.Pin = RS485_DE_Pin;//  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;//  GPIO_InitStruct.Pull = GPIO_NOPULL;//  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;//  HAL_GPIO_Init(RS485_DE_GPIO_Port, &GPIO_InitStruct);        /*Configure GPIO pins : Fault_1_Pin Fault_2_Pin Normal_Pin */        GPIO_InitStruct.Pin = Fault_1_Pin|Fault_2_Pin|Normal_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;        GPIO_InitStruct.Pull = GPIO_NOPULL;        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;        HAL_GPIO_Init(Normal_GPIO_Port, &GPIO_InitStruct);        HAL_GPIO_WritePin(GPIOE, Fault_1_Pin|Fault_2_Pin|Normal_Pin, GPIO_PIN_SET);        /*Configure GPIO pin : Encoder_2_B_Pin */        GPIO_InitStruct.Pin = Encoder_2_B_Pin;        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;        GPIO_InitStruct.Pull = GPIO_NOPULL;        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;        GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;        HAL_GPIO_Init(Encoder_2_B_GPIO_Port, &GPIO_InitStruct);        HALL1_Init_Electrical_Angle();        HALL2_Init_Electrical_Angle();    }    /* USER CODE BEGIN 4 */    /**      * 函数功能: 串口接收完成回调函数      * 输入参数: 无      * 返 回 值: 无      * 说    明：无      */    u8 PosRefDifferentiator_Flag = 0;    void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)    {        if ((UartHandle->Instance) == USART3)        {//            int ret = 0;            HAL_UART_Receive_IT(&husart_debug,&aRxBuffer,1); //使能接收，进入中断回调函数            /******************原程序*****屏蔽*******************************/#ifdef	UART_DEBUG//        RxBuffer[u16LwipR_BufId++] = aRxBuffer;//        if(u16LwipR_BufId >= 100)//        {//            u16LwipR_BufId = 0;//        }//        if((u16LwipR_BufId>6)&&RxBuffer[u16LwipR_BufId-2]==0x0A&&RxBuffer[u16LwipR_BufId-1]==0x0D)//        {//            {//                g_uart_recv_ok =1;//            }//            printf("u16LwipR_BufId = %d\n",u16LwipR_BufId);//        }#endif            /*******************2020918***************************************/#ifdef Usart_Labview            if(UsartReceiveDate<50)            {                UsartRxBuffer[UsartReceiveDate] = aRxBuffer;                if(UsartRxBuffer[0] == 0xAA)                {                    UsartReceiveDate++;                }                else                {                    UsartReceiveDate = 0 ;                }                if((UsartRxBuffer[UsartReceiveDate-1] == 0x2F)&&(UsartRxBuffer[UsartReceiveDate-2] == UsartReceiveDate))                {                    g_uart_recv_ok =1;                }            }            else            {                UsartReceiveDate = 0 ;            }#endif        }//	else if ((UartHandle->Instance) == USART1)//	{//		HAL_UART_Receive_IT(&huart3,&UART3_RxBuffer,1);////    Usart3RxBuffer[Usart3_ReceiveDate++] = UART3_RxBuffer;////		if(Usart3_ReceiveDate == 0)//		{//			if(UART3_RxBuffer == 0x7F  )//			{//				Usart3_ReceiveDate = 0;//				Usart3RxBuffer[Usart3_ReceiveDate++] = UART3_RxBuffer;//			}//			else//			{//			 Usart3_ReceiveDate = 0;//			}//	 }//		else if(Usart3_ReceiveDate == 1)//		{//			if(UART3_RxBuffer == 0x80 )//			{//				Usart3RxBuffer[Usart3_ReceiveDate++] = UART3_RxBuffer;//			}//			else//			{//				Usart3_ReceiveDate = 0;////			}//		}//		else if(Usart3_ReceiveDate < 23)//		{//		  Usart3RxBuffer[Usart3_ReceiveDate++] = UART3_RxBuffer;//			if(Usart3_ReceiveDate>=23)//			{//				HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_SET);////				Usart3_ReceiveDate_OK = 1;//				IMU_BDF_07_DATA(Usart3RxBuffer);//////					imuData_Pitch = (s32)(imuData.Pitch*imuDataScale);////				imuData_Roll = (s32)(imuData.Roll*imuDataScale);////				imuData_Yaw = (s32)(-imuData.Yaw*imuDataScale);////				imuData_Pitch = (s32)(imuData.Pitch*imuDataScale);//				imuData_Roll = (s32)(imuData.Roll*imuDataScale);//				imuData_Yaw = (s32)(-imuData.Yaw*imuDataScale);//				ENCODER_M1._Super.IMU_PulseNumber = imuData_Pitch;//				ENCODER_M2._Super.IMU_PulseNumber = imuData_Pitch;//imuData_Yaw////				if(PosRefDifferentiator_Flag == 1)//				{//					PosRefDifferentiator.v1 =  ENCODER_M1._Super.IMU_PulseNumber ;//				}//				else if(PosRefDifferentiator_Flag == 2)//				{//					PosRefDifferentiator.v1 =  -ENCODER_M1._Super.IMU_PulseNumber ;//				}////				Usart3_ReceiveDate=0;//				HAL_GPIO_WritePin(GPIOE, GPIO_PIN_1, GPIO_PIN_RESET);//			}//		}//	}    }    void HALL2_Init_Electrical_Angle( void )    {        HallState2 = (GPIOD->IDR>>5)&(0x7);        switch ( HallState2 )        {        case STATE_5:            HAL_Init_Electrical_Angle2 = (int16_t)(HALL_PHASE_SHIFT2) + S16_60_PHASE_SHIFT/2;//            break;        case STATE_1:            HAL_Init_Electrical_Angle2 = (int16_t)(HALL_PHASE_SHIFT2) + S16_60_PHASE_SHIFT + S16_60_PHASE_SHIFT/2;            break;        case STATE_3:            HAL_Init_Electrical_Angle2 = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT2) + S16_120_PHASE_SHIFT + S16_60_PHASE_SHIFT/2);            break;        case STATE_2:            HAL_Init_Electrical_Angle2 = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT2)-S16_120_PHASE_SHIFT                                         - S16_60_PHASE_SHIFT/2 );            break;        case STATE_6:            HAL_Init_Electrical_Angle2 = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT2) - S16_60_PHASE_SHIFT -  S16_60_PHASE_SHIFT/2 );            break;        case STATE_4:            HAL_Init_Electrical_Angle2 = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT2) - S16_60_PHASE_SHIFT/2 );            break;        default:            break;        }    }    void HALL1_Init_Electrical_Angle( void )    {        HallState1 = HALL_GetPhase1();        switch ( HallState1 )        {        case STATE_5:            HAL_Init_Electrical_Angle = (int16_t)(HALL_PHASE_SHIFT) + S16_60_PHASE_SHIFT/2;//            break;        case STATE_1:            HAL_Init_Electrical_Angle = (int16_t)(HALL_PHASE_SHIFT) + S16_60_PHASE_SHIFT + S16_60_PHASE_SHIFT/2;            break;        case STATE_3:            HAL_Init_Electrical_Angle = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT) + S16_120_PHASE_SHIFT + S16_60_PHASE_SHIFT/2);            break;        case STATE_2:            HAL_Init_Electrical_Angle = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT)-S16_120_PHASE_SHIFT                                        - S16_60_PHASE_SHIFT/2 );            break;        case STATE_6:            HAL_Init_Electrical_Angle = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT) - S16_60_PHASE_SHIFT -  S16_60_PHASE_SHIFT/2 );            break;        case STATE_4:            HAL_Init_Electrical_Angle = ( int16_t )( (int16_t)(HALL_PHASE_SHIFT) - S16_60_PHASE_SHIFT/2 );            break;        default:            break;        }    }    extern Trapezoidal_Handle_t  pTrapezoidalM1;    extern int32_t hSpeedRef_Pos,wError ;//Speed_PLL_Motor1,pCtrlPar[M2].Vel_PLL_Motor,//extern SENSOR_DATA_I16 MPU6050_ACC_LAST;     // 传感器ACC值//extern SENSOR_DATA_I16 MPU6050_GYRO_LAST;		// 传感器GYRO值//extern float Angle_Final,Gyro_Final;//extern SENSOR_DATA_F AccFinal,GyroFinal;    extern PWMC_Handle_t * pwmcHandle[NBR_OF_MOTORS];    extern FOCVars_t FOCVars[NBR_OF_MOTORS];    u16 Uart_TxBuffer_CNT = 0;    u16 Uart_TxBuffer_CNT1 =0;    u8 uart_counter=10;    void Labview_uart(void)    {        u16 temp_tab[5];//  if(uart_tmr == 1)//20        {            switch(uart_counter)            {            case 0:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = 23055;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = 24555;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = 30000;//speed_now;//ac_cur_aver_adj;                temp_tab[4] = 20000 ;//Emf_AD[1];                break;            case 1:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = (s16)pTrapezoidalM1.Sn*100;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = (s16)pTrapezoidalM1.Vm*1000;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (s16)CurrentPosition11*100;//speed_now;//ac_cur_aver_adj;                temp_tab[4] = pCtrlPar[M1].Vel_PLL_Motor/15.9155*1000 ;//Emf_AD[1];                break;            case 2:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = (s16)pMCI[M1]->pPosCtrl->Omega*1000;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = (s16)pMCI[M1]->pPosCtrl->Theta*100;;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (s16)pMCI[M1]->pPosCtrl->Acceleration*1000;;//speed_now;//ac_cur_aver_adj;pAxisPar.velErr[A_AXIS]                temp_tab[4] = (s16)pMCI[M1]->pPosCtrl->Jerk*1000; ;//Emf_AD[1];                break;            case 3:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;SMC_DError                temp_tab[1] = (s16)ENCODER_M1._Super.wPulseNumber ;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;Position_Reference,Position_Encoder                temp_tab[2] = (s16)pTrapezoidalM1.Sn;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (s16)ENCODER_M1._Super.hAvrMecSpeedUnit;//speed_now;//ac_cur_aver_adj;                temp_tab[4] = (s16)pCtrlPar[M1].Vel_PLL_Motor ;//Emf_AD[1];IMU_PulseNumber                break;            case 4:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = (s16)ENCODER_M1._Super.wPulseNumber;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = (s16)(ENCODER_M1._Super.IMU_PulseNumber);//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (s16)(pTrapezoidalM1.Sn);//speed_now;//ac_cur_aver_adj;                temp_tab[4] = (s16) (pCtrlPar[M1].Vel_PLL_Motor) ;//Emf_AD[1];                break;            case 5:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = (u16)FOCVars[1].Iqdref.q;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = (u16)FOCVars[1].Iqd.q;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (u16)(SpeednTorqCtrlM2.SpeedRefUnitExt/65536);//speed_now;//ac_cur_aver_adj;pAxisPar.velErr[A_AXIS]                temp_tab[4] = (u16)pCtrlPar[M2].Vel_PLL_Motor ;//Emf_AD[1];                break;            case 6:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = (s16)hSpeedRef_Pos;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;                temp_tab[2] = (s16)(SpeednTorqCtrlM1.SpeedRefUnitExt/65536);//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = (s16)(s16)ENCODER_M1._Super.hAvrMecSpeedUnit;//speed_now;//ac_cur_aver_adj;pAxisPar.velErr[A_AXIS]                temp_tab[4] = (s16)pCtrlPar[M1].Vel_PLL_Motor;//Emf_AD[1];                break;            case 7:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;SMC_DError                temp_tab[1] = (s16)hSpeedRef_Pos;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;Position_Reference,Position_Encoder                temp_tab[2] = (s16)wError;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] =(s16)(SpeednTorqCtrlM1.SpeedRefUnitExt/65536);//speed_now;//ac_cur_aver_adj;                temp_tab[4] = (s16)(ENCODER_M1._Super.IMU_PulseNumber) ;//Emf_AD[1];                break;            case 8:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = pwmcHandle[M1]->CntPhA;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;Speed_Reference,Speed_now                temp_tab[2] = pwmcHandle[M1]->CntPhB;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = pwmcHandle[M1]->CntPhC;//speed_now;//ac_cur_aver_adj;                temp_tab[4] = FOCVars[M1].hElAngle ;//Emf_AD[1];                break;            case 9:                temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;                temp_tab[1] = FOCVars[M1].Valphabeta.alpha;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;Position_Reference,Position_Encoder                temp_tab[2] = FOCVars[M1].Valphabeta.beta;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;                temp_tab[3] = FOCVars[M2].Iqd.q ;//speed_now;//ac_cur_aver_adj;                temp_tab[4] = FOCVars[M2].Iqd.d ;//Emf_AD[1];                break;#ifdef UART_DEBUG            case 10:                temp_tab[0] = 0x5A0A;;//                temp_tab[1] = (u16)LV_Uart_TxBuffer[0][Uart_TxBuffer_CNT];//                temp_tab[2] = (u16)LV_Uart_TxBuffer[1][Uart_TxBuffer_CNT];//                temp_tab[3] = (u16)LV_Uart_TxBuffer[2][Uart_TxBuffer_CNT];//                temp_tab[4] = (u16)LV_Uart_TxBuffer[3][Uart_TxBuffer_CNT] ;//                Uart_TxBuffer_CNT++;                if(Uart_TxBuffer_CNT>LV_TxBuf-1)                {                    Uart_TxBuffer_CNT = 0 ;                    Uart_TxBuffer_CNT1 =0 ;                }                break;#endif//	  case 10://            temp_tab[0] = 0x5A0A;;//TIM3->CCR1 >> 1;//            temp_tab[1] = pSpeed_Mesa.fSpeedRPM;//speed_now;//(u16)Emf_Alpha;//Emf_AD[2];//h_BusV_Average;//            temp_tab[2] = (s16)bSector*500;//(u16)Emf_Beta;//Emf_AD[0];//module_2;//module;//Stat_Curr_q_d.qI_Component1;//            temp_tab[3] = SVPWM_Data.N*500;//speed_now;//ac_cur_aver_adj;//            temp_tab[4] = (s16)wTimePhC ;//Emf_AD[1];//		    break;            default:                break;            }            LV_TxBuffer[0] = temp_tab[0]/256;            LV_TxBuffer[1] = temp_tab[0]%256;            LV_TxBuffer[2] = temp_tab[1]/256;            LV_TxBuffer[3] = temp_tab[1]%256;            LV_TxBuffer[4] = temp_tab[2]/256;            LV_TxBuffer[5] = temp_tab[2]%256;            LV_TxBuffer[6] = temp_tab[3]/256;            LV_TxBuffer[7] = temp_tab[3]%256;            LV_TxBuffer[8] = temp_tab[4]/256;            LV_TxBuffer[9] = temp_tab[4]%256;//	  HAL_UART_Transmit(&UART6_Handler, (uint8_t *)LV_TxBuffer, TxBufferSize,0x20);//	  HAL_UART_Transmit_IT(&UART6_Handler, (uint8_t *)LV_TxBuffer, TxBufferSize);            printf("%c%c%c%c%c%c%c%c%c%c",LV_TxBuffer[0],LV_TxBuffer[1],LV_TxBuffer[2],LV_TxBuffer[3],LV_TxBuffer[4],LV_TxBuffer[5],LV_TxBuffer[6],LV_TxBuffer[7],LV_TxBuffer[8],LV_TxBuffer[9]);//      TxCounter = 0;//      USART_ITConfig(USART1, USART_IT_TXE, ENABLE);//       if(rec_success==1)//      {//        rec_success=0;//        if(RxBuffer[3]==0)//          hSpeed_Reference = RxBuffer[6]*256+RxBuffer[5];//        else if(RxBuffer[3]==1)//        {//          State_Temp = RxBuffer[6]*256+RxBuffer[5];//          if(State_Temp==0)State = IDLE;//          else State = INIT;//        }//        else if(RxBuffer[3]==2)//          hSpeed_Reference = RxBuffer[6]*256+RxBuffer[5];//        else if(RxBuffer[3]==3)//          hSpeed_Reference = RxBuffer[6]*256+RxBuffer[5];//        else if(RxBuffer[3]==4)//          hSpeed_Reference = RxBuffer[6]*256+RxBuffer[5];//      }        }    }    /* USER CODE END 4 */    /**      * @brief  This function is executed in case of error occurrence.      * @retval None      */    void Error_Handler(void)    {        /* USER CODE BEGIN Error_Handler_Debug */        /* User can add his own implementation to report the HAL error return state */        /* USER CODE END Error_Handler_Debug */    }#ifdef  USE_FULL_ASSERT    /**      * @brief  Reports the name of the source file and the source line number      *         where the assert_param error has occurred.      * @param  file: pointer to the source file name      * @param  line: assert_param error line source number      * @retval None      */    void assert_failed(uint8_t *file, uint32_t line)    {        /* USER CODE BEGIN 6 */        /* User can add his own implementation to report the file name and line number,           tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */        /* USER CODE END 6 */    }#endif /* USE_FULL_ASSERT */    /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/