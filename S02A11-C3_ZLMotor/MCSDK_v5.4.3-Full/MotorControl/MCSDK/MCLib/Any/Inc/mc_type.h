/**  ******************************************************************************  * @file    mc_type.h  * @author  Motor Control SDK Team, ST Microelectronics  * @brief   Motor Control SDK global types definitions  ******************************************************************************  * @attention  *  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.  * All rights reserved.</center></h2>  *  * This software component is licensed by ST under Ultimate Liberty license  * SLA0044, the "License"; You may not use this file except in compliance with  * the License. You may obtain a copy of the License at:  *                             www.st.com/SLA0044  *  ******************************************************************************  * @ingroup MC_Type  *//* Define to prevent recursive inclusion -------------------------------------*/#ifndef __MC_TYPE_H#define __MC_TYPE_H/* Includes ------------------------------------------------------------------*/#include <stdint.h>#include <stdbool.h>#ifdef __cplusplusextern "C" {#endif /* __cplusplus *//** @addtogroup MCSDK  * @{  *//** @addtogroup MC_Type Motor Control types  * @{  *//**  * @define MISRA_C_2004_BUILD  * @brief Used to build the library with MISRA C support  *  * Uncomment #define MISRA_C_2004_BUILD to build the library including  * "stm32fxxx_MisraCompliance.h" instead of "stm32fxxx.h".  *  * This will build the library in 'strict ISO/ANSI C' and in  * compliance with MISRA C 2004 rules (check project options).  *  * @note Do not use this flag with the current version of the SDK.  *//*#define MISRA_C_2004_BUILD*/#include <mc_stm_types.h>/** @name Macros to use bit banding capability *//** @{ */#define BB_REG_BIT_SET(regAddr,bit_number) *(uint32_t *) (0x42000000+(((uint32_t)regAddr - 0x40000000 )<<5) + (bit_number <<2)) = (uint32_t)(0x1u)#define BB_REG_BIT_CLR(regAddr,bit_number) (*(uint32_t *) (0x42000000+(((uint32_t)regAddr - 0x40000000)<<5) + (bit_number <<2)) = (uint32_t)(0x0u))#define BB_REG_BIT_READ(regAddr,bit_number) (*(uint32_t *) (0x42000000+(((uint32_t)regAddr - 0x40000000)<<5) + (bit_number <<2)) )/** @} *//** @brief Not initialized pointer */#define MC_NULL    (void *)(0x0)#define pi 3.1415926#define WheelDist    40    //403 mm 42.5   *10    460-35    ?á?à??μ?2?êyê?42.5 êμ?êμ÷ê?DT???a44#define WheelDia 17     //170mm  ??×ó?±??/** @name Motor identification macros *//** @{ */#define M1      (uint8_t)(0x0)  /*!< Motor 1.*/#define M2      (uint8_t)(0x1)  /*!< Motor 2.*/#define M_NONE  (uint8_t)(0xFF) /*!< None motor.*//** @} */#define SAMPLE_FREQUENCY               	10000#define SAMPLE_TIME                     0.00005f// current protection counter#define PWM_PERIOD_IN_US							((float)SAMPLE_TIME * 1000000)#define OVER_PHASE_CURRENT_TIME_US		1000000//#define OVER_12_LOAD_CURRENT_TIME_US	600000000//#define OVER_15_LOAD_CURRENT_TIME_US	60000000//#define OVER_20_LOAD_CURRENT_TIME_US	20000000//#define OVER_25_LOAD_CURRENT_TIME_US	5000000//#define OVER_30_LOAD_CURRENT_TIME_US	1000000//#define OVER_REGEN_LOAD_TIME_US				1000000#define OVER_12_LOAD_CURRENT_TIME_US	12000000#define OVER_15_LOAD_CURRENT_TIME_US	6000000#define OVER_20_LOAD_CURRENT_TIME_US	4000000#define OVER_25_LOAD_CURRENT_TIME_US	2000000#define OVER_30_LOAD_CURRENT_TIME_US	1000000#define OVER_REGEN_LOAD_TIME_US				2000000#define	OVER_CURRENT_COUNTER_MAX			(OVER_PHASE_CURRENT_TIME_US / PWM_PERIOD_IN_US) 		// 0.25ms#define	OVER_12_LOAD_COUNTER_MAX			(OVER_12_LOAD_CURRENT_TIME_US / PWM_PERIOD_IN_US) 	// 600s#define	OVER_15_LOAD_COUNTER_MAX			(OVER_15_LOAD_CURRENT_TIME_US / PWM_PERIOD_IN_US)		// 60s#define	OVER_20_LOAD_COUNTER_MAX			(OVER_20_LOAD_CURRENT_TIME_US / PWM_PERIOD_IN_US)		// 20s#define	OVER_25_LOAD_COUNTER_MAX			(OVER_25_LOAD_CURRENT_TIME_US / PWM_PERIOD_IN_US)		// 5s#define	OVER_30_LOAD_COUNTER_MAX			(OVER_30_LOAD_CURRENT_TIME_US / PWM_PERIOD_IN_US)		// 1s#define	REGEN_OVER_LOAD_COUNTER_MAX		(OVER_REGEN_LOAD_TIME_US / PWM_PERIOD_IN_US)				// 1s#define OVER_LOAD_TYPE_CNT			4  /*过流保护阶段4个*/#define	NUMBER_OF_AXES					2	// mean currenttypedef struct _mean_curr{	long 				curr;	long 				currCnt[OVER_LOAD_TYPE_CNT];		// [1.2, 1.5, 2.0, 2.5, 3.0 contCurr peakCurr]	float 				factor[OVER_LOAD_TYPE_CNT];	long 				cntMax[OVER_LOAD_TYPE_CNT];	long 				ctrlFault[OVER_LOAD_TYPE_CNT];	long 				errCode[OVER_LOAD_TYPE_CNT];	long 				cmpVal[OVER_LOAD_TYPE_CNT];	long        ErrCode;//	uint16_t   errType[2][6] = {0};//  uint16_t   ErrType[2];} LOAD_CURR;   /*STM[M1].hFaultOccurred*/#define  MC_NO_ERROR  				0X00000000   //无错误#define  MC_NO_FAULTS  				0X00000000   //无错误#define  MC_FOC_DURATION 			0X00000001   //FOC rate to high#define  MC_OVER_VOLT  				0X00000002   //过压  公共错误1#define  MC_UNDER_VOLT  			0X00000004   //欠压  公共错误2#define  MC_OVER_TEMP  				0X00000008   //过温#define  ERR_HALL   				  0X00000010       //霍尔错误#define  MC_SPEED_FDBK  			0X00000020     //速度反馈错误 （无传感器模式使用）#define  MC_BREAK_IN  				0X00000040     //短路保护#define  MC_SW_ERROR  				0X00000080     //软件错误  公共错误3#define	ERR_CURR_13_OVER_LOAD				0x00000100  	//1.2倍过载 1<<8#define	ERR_CURR_15_OVER_LOAD				0x00000200  	//1.5倍过载 1<<9#define	ERR_CURR_OVER_MAX				    0x00000400  	//2.0倍过载 1<<10#define TURN_ON_R_BRAKE						  0x00000800		//刹车电阻#define ERR_MOTOR_STUCK_ERR         0x00001000		//堵转#define ERR_OVER_VEL_ERR						0x00002000    //失速#define ERR_POS_FOLLOWING_ERR 			0x00004000    //位置跟随错误#define ERR_HALL_STUDY							0x00008000    //霍尔学习错误#define ERR_CAN_COMMUNICATION				0x00010000    //CAN通信错误  公共错误4#define ERR_LOST_PHASE              0x00020000    //缺相报警/*wGlobal_Flags*/#define  ERR_ENCODER_M1   			0X00000010   //编码器错误#define  ERR_ENCODER_M2					0X00000020   //编码器错误#define  MC_BREAK_IN_M1  				0X00000040     //短路保护#define  MC_BREAK_IN_M2  				0X00000080     //短路保护#define ERR_CURR_OVER_MAX_M1					  0x00000100    //过流		  #define ERR_CURR_OVER_MAX_M2					  0x00000200    //过流#define ERR_MOTOR_STUCK_ERR_M1          0x00000400		//堵转#define ERR_MOTOR_STUCK_ERR_M2          0x00000800		//堵转#define ERR_OVER_VEL_ERR_M1					    0x00001000    //失速#define ERR_OVER_VEL_ERR_M2					    0x00002000    //失速#define ERR_POS_FOLLOWING_ERR_M1 			  0x00004000    //位置跟随错误#define ERR_POS_FOLLOWING_ERR_M2 			  0x00008000    //位置跟随错误#define ERR_CAN_COMMUNICATION				    0x00010000    //CAN通信错误  公共错误4#define ERR_LOST_PHASE_M1               0x00020000    //缺相报警#define ERR_LOST_PHASE_M2               0x00040000    //缺相报警#define ERR_HALL_M1											0x00080000  	//霍尔错误#define ERR_HALL_M2											0x00100000 		//霍尔错误#define MC_OVER_TEMP_M1									0x00200000  	//过温#define MC_OVER_TEMP_M2									0x00400000 		//过温/** @name Dual motor Frequency comparison definition *//** @{ */#define SAME_FREQ   0u#define HIGHER_FREQ 1u#define LOWER_FREQ  2u#define HIGHEST_FREQ 1u#define LOWEST_FREQ  2u/** @} *//**  * @brief union type definition for u32 to Float conversion and vice versa  */typedef union _FLOAT_U32_{	uint32_t	U32_Val;	float		Float_Val;} FloatToU32;/**  * @brief Two components q, d type definition  */typedef struct{  int32_t q;  int32_t d;} qd_t;   //?-16/**  * @brief Two components a,b type definition  */typedef struct{  int32_t a;  int32_t b;} ab_t;//typedef struct//{//  int16_t a;//  int16_t b;//} ab_t;/**  * @brief Two components alpha, beta type definition  */typedef struct{  int16_t alpha;  int16_t beta;} alphabeta_t;/**  * @brief  ADConv_t type definition, it is used by PWMC_ADC_SetSamplingTime method of PWMnCurrFdbk class for user defined A/D regular conversions  */typedef struct{  uint8_t Channel;   /*!< Integer channel number, from 0 to 15 */  uint8_t SamplTime; /*!< Sampling time selection, ADC_SampleTime_nCycles5                          in case of STM32F10x, n= 1, 3, ...; */} ADConv_t;/**  * @brief  SensorType_t type definition, it's used in BusVoltageSensor and TemperatureSensor component parameters structures  *       to specify whether the sensor is real or emulated by SW  */typedef enum{  REAL_SENSOR, VIRTUAL_SENSOR} SensorType_t;/**  * @brief  DOutputState_t type definition, it's used by DOUT_SetOutputState method of DigitalOutput class to specify the  *     required output state  */typedef enum{  INACTIVE, ACTIVE} DOutputState_t;/**  * @brief  STC_Modality_t type definition, it's used by STC_SetControlMode and STC_GetControlMode methods in  *         SpeednTorqCtrl class to specify the control modality type  */typedef enum{  STC_TORQUE_MODE, /**< @brief Torque mode.*/  STC_SPEED_MODE ,  /**< @brief Speed mode.*/	STC_POSITION_MODE   /**< @brief Speed mode.*/} STC_Modality_t;/**  * @brief IMFF_PMSM class, structure type definition for feed-forward constants tuning  */typedef struct{  int32_t wConst_1D;  int32_t wConst_1Q;  int32_t wConst_2;} IMFF_TuningStruct_t, FF_TuningStruct_t;/**  * @brief  Current references source type, internal or external to FOCDriveClass  */typedef enum{  INTERNAL, EXTERNAL} CurrRefSource_t ;/**  * @brief  FOC variables structure  */typedef struct{  ab_t Iab;         /**< @brief Stator current on stator reference frame abc */  alphabeta_t Ialphabeta;  /**< @brief Stator current on stator reference frame alfa-beta*/  qd_t IqdHF;       /**< @brief Stator current on stator reference frame alfa-beta*/  qd_t Iqd;         /**< @brief Stator current on rotor reference frame qd */  qd_t Iqdref;      /**< @brief Stator current on rotor reference frame qd */  int16_t UserIdref;           /**< @brief User value for the Idref stator current */  qd_t Vqd;         /**< @brief Phase voltage on rotor reference frame qd */  alphabeta_t Valphabeta;  /**< @brief Phase voltage on stator reference frame alpha-beta*/  int32_t hTeref;              /**< @brief Reference torque */    //?-16  int32_t hElAngle;            /**< @brief Electrical angle used for reference frame transformation  */  //?-16  uint16_t hCodeError;         /**< @brief error message */  CurrRefSource_t bDriveInput; /**< @brief It specifies whether the current reference source must be                                 *         #INTERNAL or #EXTERNAL*/} FOCVars_t, *pFOCVars_t;typedef struct{	long PolePairNum;      //极对数	long ConstantTorque;   //力矩常数  long ConstantInertia;  //转动惯量  long RatedCurrent;     //额定电流	long RatedTorque ;     //额定力矩	long RatedSpeed ;      //额定速度	long PulseNumber;      //编码器线束	long PeakCurrent ;     //峰值电流	long PeakTicks ;       //峰值电流持续时间	long MAXPhaseCurrent ; //最大相电流	long MAXSpeed ;	       //最大速度	long LockedSpeed ;     //堵转速度	long ShortCircuit ;    //堵转电流	long LockeTicks;	     //堵转计数	long PhaseTicks;       //缺相计数	long MaxTemperature;   //最高温度	long OverTemperatureTicks; //过温计时}MotorParameters_t;/**  * @brief  Low side or enabling signal definition  */typedef enum{  LS_DISABLED  = 0x0U,    /**< @brief Low side signals and enabling signals always off.                                         It is equivalent to DISABLED. */  LS_PWM_TIMER = 0x1U,  /**< @brief Low side PWM signals are generated by timer. It is                                         equivalent to ENABLED. */  ES_GPIO   = 0x2U             /**< @brief Enabling signals are managed by GPIOs (L6230 mode).*/} LowSideOutputsFunction_t, *pLowSideOutputsFunction_t;/**  * @brief  MPInfo structure (used only for serial communication)  */typedef struct{  uint8_t * data;  uint8_t len;} MPInfo_t, *pMPInfo_t;typedef struct{    float fAngle;                            //±à???÷???è	  float fPreAngle;                         //é?ò?′?±à???÷???è    float fAngleLast;                        //×??ü?üD?μ?±à???÷???è    float fKfilter;                          //??2¨?μêy    float fSpeedRPM_Temp;                    //????μ?êμê±?ù?è    float fSpeedRPM;                         //PLL?ù?è    float fSpeedFilter;                      //??2¨oó?ù?è    float fSpeedCorrection;                  //DT?yoó?ù?è      float fSpeed_CorrectionFactor;           //?ù?èDT?y?μêy ?-float    int32_t fPLL_Kp;    float fProportional_Term;	  int32_t fPLL_Ki;//	  float fPLL_Ki;//	  float fSpeed_CorrectionFactor;           //?ù?èDT?y?μêy ?-float//    float fPLL_Kp;	      float fIntegral_Term;	float fTsw;                               //2é?ùê±??} pSpeedMesa;//typedef struct//{//  long Err[NUMBER_OF_AXES];              //?ó2?//  long DErr[NUMBER_OF_AXES];             //?ó2?μ??￠・?//  long PreErr[NUMBER_OF_AXES];           //é?′??ó2?////  float Upper_Limit_Output;////  float Lower_Limit_Output;////  float DReference;         //ê?è?μ??￠・?////  float PreReference;       //é?′?ê?è?////  float	DDReference;        //ê?è?μ??t?×?￠・?////  float PreDReference;      //é?′?ê?è?μ??￠・?//  float cSMC[NUMBER_OF_AXES];           //  float kSMC[NUMBER_OF_AXES];//  float eSMC[NUMBER_OF_AXES];//  float  s[NUMBER_OF_AXES];//  long  Output[NUMBER_OF_AXES];//  long  Integrator[NUMBER_OF_AXES];//	int8_t  sgn;//} SMC;/*-----???￡2?êy?á11ì?-----*/typedef struct{  float Err;              //?ó2?  float DErr;             //?ó2?μ??￠・?  float PreErr;           //é?′??ó2?  float Upper_Limit_Output;  float Lower_Limit_Output;  float DReference;         //ê?è?μ??￠・?  float PreReference;       //é?′?ê?è?  float	DDReference;        //ê?è?μ??t?×?￠・?  float PreDReference;      //é?′?ê?è?μ??￠・?  float	cSMC;             float kSMC;  float eSMC;  float s;	long  Integrator;  float Output;	float SMC_OUTPUT_MAX;	int8_t  sgn;} SMC;typedef struct {  double Ax; // Accel x axis  double Ay; // Accel y axis  double Az; // Accel z axis  double Gx; // Gyro x axis  double Gy; // Gyro y axis  double Gz; // Gyro z axis  double Roll; // Roll  double Pitch; // Pitch  double Yaw; // Yaw  double Temp; // Temperature}IMU_DATA;extern SMC SMC_Struct;//typedef struct//{//  s16  LaV_Tx_Value1[2000];   //s16 LaV_Tx_Value1[2000],LaV_Tx_Value2[2000],LaV_Tx_Value3[2000],LaV_Tx_Value4[2000];//s16 LaV_Tx_Flag = 0;//u32 LaV_Tx_Counter=0;//  float DErr;             //  float PreErr;           //  float Upper_Limit_Output;//  float Lower_Limit_Output;//  float DReference;         //  float PreReference;       //  float	DDReference;       //  float PreDReference;      //é?′?ê?è?μ??￠・?  //  float	cSMC;           //  float kSMC;//  float eSMC;//  float s;//	long  Integrator;//  float Output;//	float SMC_OUTPUT_MAX;//	int8_t  sgn;//} LabView_TX;extern u8 PID_SMC_Flag[3];/** @name UserInterface related exported definitions *//** @{ */#define OPT_NONE    0x00 /**< @brief No UI option selected. */#define OPT_COM     0x02 /**< @brief Bit field indicating that the UI uses serial communication. */#define OPT_DAC     0x04 /**< @brief Bit field indicating that the UI uses real DAC. */#define OPT_DACT    0x08 /**< @brief Bit field indicating that the UI uses RC Timer DAC. */#define OPT_DACS    0x10 /**< @brief Bit field indicating that the UI uses SPI communication. */#define OPT_DACF3   0x40 /**< @brief Bit field indicating that the UI uses DAC for STM32F3. */#define OPT_DACF072 0x80 /**< @brief Bit field indicating that the UI uses DAC for STM32F072. *//** @} */#define MAIN_SCFG_POS (28)#define AUX_SCFG_POS (24)#define MAIN_SCFG_VALUE(x) (((x)>>MAIN_SCFG_POS)&0x0F)#define AUX_SCFG_VALUE(x)  (((x)>>AUX_SCFG_POS)&0x0F)/** @name PFC related exported definitions *//** @{ */#define PFC_SWE             0x0001u /**< @brief PFC Software error. */#define PFC_HW_PROT         0x0002u /**< @brief PFC hardware protection. */#define PFC_SW_OVER_VOLT    0x0004u /**< @brief PFC software over voltage. */#define PFC_SW_OVER_CURRENT 0x0008u /**< @brief PFC software over current. */#define PFC_SW_MAINS_FREQ   0x0010u /**< @brief PFC mains frequency error. */#define PFC_SW_MAIN_VOLT    0x0020u /**< @brief PFC mains voltage error. *//** @} *//** @name Definitions exported for the DAC channel used as reference for protection *//** @{ */#define AO_DISABLED 0x00u /**< @brief Analog output disabled.*/#define AO_DEBUG    0x01u /**< @brief Analog output debug.*/#define VREF_OCPM1  0x02u /**< @brief Voltage reference for over current protection of motor 1.*/#define VREF_OCPM2  0x03u /**< @brief Voltage reference for over current protection of motor 2.*/#define VREF_OCPM12 0x04u /**< @brief Voltage reference for over current protection of both motors.*/#define VREF_OVPM12 0x05u /**< @brief Voltage reference for over voltage protection of both motors.*//** @} *//** @name ADC channel number definitions *//** @{ */#define MC_ADC_CHANNEL_0     0#define MC_ADC_CHANNEL_1     1#define MC_ADC_CHANNEL_2     2#define MC_ADC_CHANNEL_3     3#define MC_ADC_CHANNEL_4     4#define MC_ADC_CHANNEL_5     5#define MC_ADC_CHANNEL_6     6#define MC_ADC_CHANNEL_7     7#define MC_ADC_CHANNEL_8     8#define MC_ADC_CHANNEL_9     9#define MC_ADC_CHANNEL_10    10#define MC_ADC_CHANNEL_11    11#define MC_ADC_CHANNEL_12    12#define MC_ADC_CHANNEL_13    13#define MC_ADC_CHANNEL_14    14#define MC_ADC_CHANNEL_15    15#define MC_ADC_CHANNEL_16    16#define MC_ADC_CHANNEL_17    17#define MC_ADC_CHANNEL_18    18/** @} *///#define UART_DEBUG   #define Usart_Labview   /** @name Utility macros definitions *//** @{ */#define RPM2MEC01HZ(rpm) (int16_t)((int32_t)(rpm)/6)/** @} *//**  * @}  *//**  * @}  */#ifdef __cplusplus}#endif /* __cpluplus */#endif /* __MC_TYPE_H *//******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/